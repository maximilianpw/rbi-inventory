/**
 * Generated by orval v7.16.1 ðŸº
 * Do not edit manually.
 * RBI Inventory API
 * REST API for RBI Inventory Management System
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import { getAxiosInstance } from './axios-client'
export interface ProfileResponseDto {
  [key: string]: unknown
}

export interface ErrorResponseDto {
  error: string
}

export interface SessionClaimsResponseDto {
  user_id: string
  session_id: string
  expires_at: number
  issued_at: number
}

export type UserResponseDtoRole =
  (typeof UserResponseDtoRole)[keyof typeof UserResponseDtoRole]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserResponseDtoRole = {
  ADMIN: 'ADMIN',
  WAREHOUSE_MANAGER: 'WAREHOUSE_MANAGER',
  PICKER: 'PICKER',
  SALES: 'SALES',
} as const

export interface UserResponseDto {
  id: string
  name: string
  email: string
  role: UserResponseDtoRole
  is_active: boolean
  /** @nullable */
  last_login: string | null
  created_at: string
  updated_at: string
}

export type CreateUserDtoRole =
  (typeof CreateUserDtoRole)[keyof typeof CreateUserDtoRole]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateUserDtoRole = {
  ADMIN: 'ADMIN',
  WAREHOUSE_MANAGER: 'WAREHOUSE_MANAGER',
  PICKER: 'PICKER',
  SALES: 'SALES',
} as const

export interface CreateUserDto {
  /**
   * @minLength 2
   * @maxLength 100
   */
  name: string
  email: string
  role: CreateUserDtoRole
}

export type UpdateUserDtoRole =
  (typeof UpdateUserDtoRole)[keyof typeof UpdateUserDtoRole]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateUserDtoRole = {
  ADMIN: 'ADMIN',
  WAREHOUSE_MANAGER: 'WAREHOUSE_MANAGER',
  PICKER: 'PICKER',
  SALES: 'SALES',
} as const

export interface UpdateUserDto {
  /**
   * @minLength 2
   * @maxLength 100
   */
  name?: string
  email?: string
  role?: UpdateUserDtoRole
  is_active?: boolean
}

export interface MessageResponseDto {
  message: string
}

export interface CategoryWithChildrenResponseDto {
  id: string
  name: string
  /** @nullable */
  parent_id: string | null
  /** @nullable */
  description: string | null
  created_at: string
  updated_at: string
  children: CategoryWithChildrenResponseDto[]
}

export interface CreateCategoryDto {
  /**
   * @minLength 1
   * @maxLength 100
   */
  name: string
  /** @nullable */
  parent_id?: string | null
  /**
   * @maxLength 500
   * @nullable
   */
  description?: string | null
}

export interface CategoryResponseDto {
  id: string
  name: string
  /** @nullable */
  parent_id: string | null
  /** @nullable */
  description: string | null
  created_at: string
  updated_at: string
}

export interface UpdateCategoryDto {
  /**
   * @minLength 1
   * @maxLength 100
   */
  name?: string
  /** @nullable */
  parent_id?: string | null
  /**
   * @maxLength 500
   * @nullable
   */
  description?: string | null
}

export interface ProductResponseDto {
  id: string
  sku: string
  name: string
  /** @nullable */
  description: string | null
  category_id: string
  /** @nullable */
  brand_id: string | null
  /** @nullable */
  volume_ml: number | null
  /** @nullable */
  weight_kg: number | null
  /** @nullable */
  dimensions_cm: string | null
  /** @nullable */
  standard_cost: number | null
  /** @nullable */
  standard_price: number | null
  /** @nullable */
  markup_percentage: number | null
  reorder_point: number
  /** @nullable */
  primary_supplier_id: string | null
  /** @nullable */
  supplier_sku: string | null
  is_active: boolean
  is_perishable: boolean
  /** @nullable */
  notes: string | null
  created_at: string
  updated_at: string
}

export interface CreateProductDto {
  /**
   * @minLength 1
   * @maxLength 50
   */
  sku: string
  /**
   * @minLength 1
   * @maxLength 200
   */
  name: string
  /**
   * @maxLength 1000
   * @nullable
   */
  description?: string | null
  category_id: string
  /** @nullable */
  brand_id?: string | null
  /**
   * @minimum 1
   * @nullable
   */
  volume_ml?: number | null
  /**
   * @minimum 0
   * @nullable
   */
  weight_kg?: number | null
  /**
   * @maxLength 50
   * @nullable
   */
  dimensions_cm?: string | null
  /**
   * @minimum 0
   * @nullable
   */
  standard_cost?: number | null
  /**
   * @minimum 0
   * @nullable
   */
  standard_price?: number | null
  /**
   * @minimum 0
   * @maximum 1000
   * @nullable
   */
  markup_percentage?: number | null
  /** @minimum 0 */
  reorder_point: number
  /** @nullable */
  primary_supplier_id?: string | null
  /**
   * @maxLength 50
   * @nullable
   */
  supplier_sku?: string | null
  is_active: boolean
  is_perishable: boolean
  /**
   * @maxLength 500
   * @nullable
   */
  notes?: string | null
}

export interface UpdateProductDto {
  /**
   * @minLength 1
   * @maxLength 50
   */
  sku?: string
  /**
   * @minLength 1
   * @maxLength 200
   */
  name?: string
  /**
   * @maxLength 1000
   * @nullable
   */
  description?: string | null
  /** @nullable */
  category_id?: string | null
  /** @nullable */
  brand_id?: string | null
  /**
   * @minimum 1
   * @nullable
   */
  volume_ml?: number | null
  /**
   * @minimum 0
   * @nullable
   */
  weight_kg?: number | null
  /**
   * @maxLength 50
   * @nullable
   */
  dimensions_cm?: string | null
  /**
   * @minimum 0
   * @nullable
   */
  standard_cost?: number | null
  /**
   * @minimum 0
   * @nullable
   */
  standard_price?: number | null
  /**
   * @minimum 0
   * @maximum 1000
   * @nullable
   */
  markup_percentage?: number | null
  /**
   * @minimum 0
   * @nullable
   */
  reorder_point?: number | null
  /** @nullable */
  primary_supplier_id?: string | null
  /**
   * @maxLength 50
   * @nullable
   */
  supplier_sku?: string | null
  /** @nullable */
  is_active?: boolean | null
  /** @nullable */
  is_perishable?: boolean | null
  /**
   * @maxLength 500
   * @nullable
   */
  notes?: string | null
}

export type HealthCheck200 = {
  status?: string
  timestamp?: string
}

export type SearchUsersParams = {
  /**
   * Search query
   */
  q: string
}

export const appControllerGetHello = (signal?: AbortSignal) => {
  return getAxiosInstance<void>({ url: `/`, method: 'GET', signal })
}

export const getAppControllerGetHelloQueryKey = () => {
  return [`/`] as const
}

export const getAppControllerGetHelloQueryOptions = <
  TData = Awaited<ReturnType<typeof appControllerGetHello>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof appControllerGetHello>>,
      TError,
      TData
    >
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof appControllerGetHello>>
  > = ({ signal }) => appControllerGetHello(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof appControllerGetHello>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerGetHelloQueryResult = NonNullable<
  Awaited<ReturnType<typeof appControllerGetHello>>
>
export type AppControllerGetHelloQueryError = unknown

export function useAppControllerGetHello<
  TData = Awaited<ReturnType<typeof appControllerGetHello>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appControllerGetHello>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAppControllerGetHello<
  TData = Awaited<ReturnType<typeof appControllerGetHello>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appControllerGetHello>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAppControllerGetHello<
  TData = Awaited<ReturnType<typeof appControllerGetHello>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appControllerGetHello>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useAppControllerGetHello<
  TData = Awaited<ReturnType<typeof appControllerGetHello>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof appControllerGetHello>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getAppControllerGetHelloQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Returns the health status of the API
 * @summary Health check endpoint
 */
export const healthCheck = (signal?: AbortSignal) => {
  return getAxiosInstance<HealthCheck200>({
    url: `/health-check`,
    method: 'GET',
    signal,
  })
}

export const getHealthCheckQueryKey = () => {
  return [`/health-check`] as const
}

export const getHealthCheckQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getHealthCheckQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({
    signal,
  }) => healthCheck(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheck>>
>
export type HealthCheckQueryError = unknown

export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Health check endpoint
 */

export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves the current user profile from Clerk
 * @summary Get user profile
 */
export const getProfile = (signal?: AbortSignal) => {
  return getAxiosInstance<ProfileResponseDto>({
    url: `/api/v1/auth/profile`,
    method: 'GET',
    signal,
  })
}

export const getGetProfileQueryKey = () => {
  return [`/api/v1/auth/profile`] as const
}

export const getGetProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProfileQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfile>>> = ({
    signal,
  }) => getProfile(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProfileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProfile>>
>
export type GetProfileQueryError = ErrorResponseDto

export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          Awaited<ReturnType<typeof getProfile>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          Awaited<ReturnType<typeof getProfile>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get user profile
 */

export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProfileQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves the current session JWT claims
 * @summary Get session claims
 */
export const getSessionClaims = (signal?: AbortSignal) => {
  return getAxiosInstance<SessionClaimsResponseDto>({
    url: `/api/v1/auth/session-claims`,
    method: 'GET',
    signal,
  })
}

export const getGetSessionClaimsQueryKey = () => {
  return [`/api/v1/auth/session-claims`] as const
}

export const getGetSessionClaimsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSessionClaims>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetSessionClaimsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSessionClaims>>
  > = ({ signal }) => getSessionClaims(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSessionClaims>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionClaimsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSessionClaims>>
>
export type GetSessionClaimsQueryError = ErrorResponseDto

export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionClaims>>,
          TError,
          Awaited<ReturnType<typeof getSessionClaims>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionClaims>>,
          TError,
          Awaited<ReturnType<typeof getSessionClaims>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get session claims
 */

export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetSessionClaimsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves all users in the system
 * @summary List all users
 */
export const listUsers = (signal?: AbortSignal) => {
  return getAxiosInstance<UserResponseDto[]>({
    url: `/api/v1/users`,
    method: 'GET',
    signal,
  })
}

export const getListUsersQueryKey = () => {
  return [`/api/v1/users`] as const
}

export const getListUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsers>>> = ({
    signal,
  }) => listUsers(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof listUsers>>
>
export type ListUsersQueryError = ErrorResponseDto

export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List all users
 */

export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Creates a new user in the system
 * @summary Create user
 */
export const createUser = (
  createUserDto: CreateUserDto,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<UserResponseDto>({
    url: `/api/v1/users`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createUserDto,
    signal,
  })
}

export const getCreateUserMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: CreateUserDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: CreateUserDto },
  TContext
> => {
  const mutationKey = ['createUser']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    { data: CreateUserDto }
  > = (props) => {
    const { data } = props ?? {}

    return createUser(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>
export type CreateUserMutationBody = CreateUserDto
export type CreateUserMutationError = ErrorResponseDto

/**
 * @summary Create user
 */
export const useCreateUser = <TError = ErrorResponseDto, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUser>>,
      TError,
      { data: CreateUserDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: CreateUserDto },
  TContext
> => {
  const mutationOptions = getCreateUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Searches for users by name (partial match)
 * @summary Search users by name
 */
export const searchUsers = (
  params: SearchUsersParams,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<UserResponseDto[]>({
    url: `/api/v1/users/search`,
    method: 'GET',
    params,
    signal,
  })
}

export const getSearchUsersQueryKey = (params?: SearchUsersParams) => {
  return [`/api/v1/users/search`, ...(params ? [params] : [])] as const
}

export const getSearchUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = ErrorResponseDto,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getSearchUsersQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchUsers>>> = ({
    signal,
  }) => searchUsers(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchUsers>>
>
export type SearchUsersQueryError = ErrorResponseDto

export function useSearchUsers<
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = ErrorResponseDto,
>(
  params: SearchUsersParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsers>>,
          TError,
          Awaited<ReturnType<typeof searchUsers>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSearchUsers<
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = ErrorResponseDto,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsers>>,
          TError,
          Awaited<ReturnType<typeof searchUsers>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSearchUsers<
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = ErrorResponseDto,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Search users by name
 */

export function useSearchUsers<
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = ErrorResponseDto,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getSearchUsersQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves a specific user by UUID
 * @summary Get user by ID
 */
export const getUser = (id: string, signal?: AbortSignal) => {
  return getAxiosInstance<UserResponseDto>({
    url: `/api/v1/users/${id}`,
    method: 'GET',
    signal,
  })
}

export const getGetUserQueryKey = (id?: string) => {
  return [`/api/v1/users/${id}`] as const
}

export const getGetUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({
    signal,
  }) => getUser(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type GetUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUser>>
>
export type GetUserQueryError = ErrorResponseDto

export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get user by ID
 */

export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetUserQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Updates an existing user
 * @summary Update user
 */
export const updateUser = (id: string, updateUserDto: UpdateUserDto) => {
  return getAxiosInstance<UserResponseDto>({
    url: `/api/v1/users/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateUserDto,
  })
}

export const getUpdateUserMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { id: string; data: UpdateUserDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: UpdateUserDto },
  TContext
> => {
  const mutationKey = ['updateUser']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { id: string; data: UpdateUserDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateUser(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>
export type UpdateUserMutationBody = UpdateUserDto
export type UpdateUserMutationError = ErrorResponseDto

/**
 * @summary Update user
 */
export const useUpdateUser = <TError = ErrorResponseDto, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateUser>>,
      TError,
      { id: string; data: UpdateUserDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: UpdateUserDto },
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Deletes a user from the system
 * @summary Delete user
 */
export const deleteUser = (id: string) => {
  return getAxiosInstance<MessageResponseDto>({
    url: `/api/v1/users/${id}`,
    method: 'DELETE',
  })
}

export const getDeleteUserMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { id: string },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteUser']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUser>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteUser(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUser>>
>

export type DeleteUserMutationError = ErrorResponseDto

/**
 * @summary Delete user
 */
export const useDeleteUser = <TError = ErrorResponseDto, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteUser>>,
      TError,
      { id: string },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Retrieves all product categories with their child categories
 * @summary List all categories
 */
export const listCategories = (signal?: AbortSignal) => {
  return getAxiosInstance<CategoryWithChildrenResponseDto[]>({
    url: `/api/v1/categories`,
    method: 'GET',
    signal,
  })
}

export const getListCategoriesQueryKey = () => {
  return [`/api/v1/categories`] as const
}

export const getListCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListCategoriesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listCategories>>> = ({
    signal,
  }) => listCategories(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListCategoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof listCategories>>
>
export type ListCategoriesQueryError = ErrorResponseDto

export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCategories>>,
          TError,
          Awaited<ReturnType<typeof listCategories>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCategories>>,
          TError,
          Awaited<ReturnType<typeof listCategories>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List all categories
 */

export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListCategoriesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Creates a new product category
 * @summary Create category
 */
export const createCategory = (
  createCategoryDto: CreateCategoryDto,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<CategoryResponseDto>({
    url: `/api/v1/categories`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createCategoryDto,
    signal,
  })
}

export const getCreateCategoryMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCategory>>,
    TError,
    { data: CreateCategoryDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: CreateCategoryDto },
  TContext
> => {
  const mutationKey = ['createCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCategory>>,
    { data: CreateCategoryDto }
  > = (props) => {
    const { data } = props ?? {}

    return createCategory(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCategory>>
>
export type CreateCategoryMutationBody = CreateCategoryDto
export type CreateCategoryMutationError = ErrorResponseDto

/**
 * @summary Create category
 */
export const useCreateCategory = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCategory>>,
      TError,
      { data: CreateCategoryDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: CreateCategoryDto },
  TContext
> => {
  const mutationOptions = getCreateCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Updates an existing product category
 * @summary Update category
 */
export const updateCategory = (
  id: string,
  updateCategoryDto: UpdateCategoryDto,
) => {
  return getAxiosInstance<CategoryResponseDto>({
    url: `/api/v1/categories/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateCategoryDto,
  })
}

export const getUpdateCategoryMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCategory>>,
    TError,
    { id: string; data: UpdateCategoryDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { id: string; data: UpdateCategoryDto },
  TContext
> => {
  const mutationKey = ['updateCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCategory>>,
    { id: string; data: UpdateCategoryDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateCategory(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCategory>>
>
export type UpdateCategoryMutationBody = UpdateCategoryDto
export type UpdateCategoryMutationError = ErrorResponseDto

/**
 * @summary Update category
 */
export const useUpdateCategory = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateCategory>>,
      TError,
      { id: string; data: UpdateCategoryDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { id: string; data: UpdateCategoryDto },
  TContext
> => {
  const mutationOptions = getUpdateCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Deletes a product category
 * @summary Delete category
 */
export const deleteCategory = (id: string) => {
  return getAxiosInstance<MessageResponseDto>({
    url: `/api/v1/categories/${id}`,
    method: 'DELETE',
  })
}

export const getDeleteCategoryMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCategory>>,
    TError,
    { id: string },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteCategory>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCategory>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteCategory(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCategory>>
>

export type DeleteCategoryMutationError = ErrorResponseDto

/**
 * @summary Delete category
 */
export const useDeleteCategory = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteCategory>>,
      TError,
      { id: string },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteCategory>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Retrieves all products in the catalog
 * @summary List all products
 */
export const listProducts = (signal?: AbortSignal) => {
  return getAxiosInstance<ProductResponseDto[]>({
    url: `/api/v1/products`,
    method: 'GET',
    signal,
  })
}

export const getListProductsQueryKey = () => {
  return [`/api/v1/products`] as const
}

export const getListProductsQueryOptions = <
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListProductsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listProducts>>> = ({
    signal,
  }) => listProducts(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListProductsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listProducts>>
>
export type ListProductsQueryError = ErrorResponseDto

export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProducts>>,
          TError,
          Awaited<ReturnType<typeof listProducts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProducts>>,
          TError,
          Awaited<ReturnType<typeof listProducts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List all products
 */

export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListProductsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Creates a new product in the catalog
 * @summary Create product
 */
export const createProduct = (
  createProductDto: CreateProductDto,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponseDto>({
    url: `/api/v1/products`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createProductDto,
    signal,
  })
}

export const getCreateProductMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProduct>>,
    TError,
    { data: CreateProductDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { data: CreateProductDto },
  TContext
> => {
  const mutationKey = ['createProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProduct>>,
    { data: CreateProductDto }
  > = (props) => {
    const { data } = props ?? {}

    return createProduct(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProduct>>
>
export type CreateProductMutationBody = CreateProductDto
export type CreateProductMutationError = ErrorResponseDto

/**
 * @summary Create product
 */
export const useCreateProduct = <TError = ErrorResponseDto, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProduct>>,
      TError,
      { data: CreateProductDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { data: CreateProductDto },
  TContext
> => {
  const mutationOptions = getCreateProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Retrieves all products in a specific category
 * @summary Get products by category
 */
export const getProductsByCategory = (
  categoryId: string,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponseDto[]>({
    url: `/api/v1/products/category/${categoryId}`,
    method: 'GET',
    signal,
  })
}

export const getGetProductsByCategoryQueryKey = (categoryId?: string) => {
  return [`/api/v1/products/category/${categoryId}`] as const
}

export const getGetProductsByCategoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetProductsByCategoryQueryKey(categoryId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProductsByCategory>>
  > = ({ signal }) => getProductsByCategory(categoryId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!categoryId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductsByCategory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductsByCategoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProductsByCategory>>
>
export type GetProductsByCategoryQueryError = ErrorResponseDto

export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get products by category
 */

export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProductsByCategoryQueryOptions(categoryId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves all products in a category and its child categories
 * @summary Get products by category tree
 */
export const getProductsByCategoryTree = (
  categoryId: string,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponseDto[]>({
    url: `/api/v1/products/category/${categoryId}/tree`,
    method: 'GET',
    signal,
  })
}

export const getGetProductsByCategoryTreeQueryKey = (categoryId?: string) => {
  return [`/api/v1/products/category/${categoryId}/tree`] as const
}

export const getGetProductsByCategoryTreeQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetProductsByCategoryTreeQueryKey(categoryId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProductsByCategoryTree>>
  > = ({ signal }) => getProductsByCategoryTree(categoryId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!categoryId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductsByCategoryTree>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductsByCategoryTreeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProductsByCategoryTree>>
>
export type GetProductsByCategoryTreeQueryError = ErrorResponseDto

export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategoryTree>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategoryTree>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategoryTree>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategoryTree>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get products by category tree
 */

export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProductsByCategoryTreeQueryOptions(
    categoryId,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves a specific product by UUID
 * @summary Get product by ID
 */
export const getProduct = (id: string, signal?: AbortSignal) => {
  return getAxiosInstance<ProductResponseDto>({
    url: `/api/v1/products/${id}`,
    method: 'GET',
    signal,
  })
}

export const getGetProductQueryKey = (id?: string) => {
  return [`/api/v1/products/${id}`] as const
}

export const getGetProductQueryOptions = <
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProductQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProduct>>> = ({
    signal,
  }) => getProduct(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProduct>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProduct>>
>
export type GetProductQueryError = ErrorResponseDto

export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get product by ID
 */

export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProductQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Updates an existing product
 * @summary Update product
 */
export const updateProduct = (
  id: string,
  updateProductDto: UpdateProductDto,
) => {
  return getAxiosInstance<ProductResponseDto>({
    url: `/api/v1/products/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateProductDto,
  })
}

export const getUpdateProductMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProduct>>,
    TError,
    { id: string; data: UpdateProductDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { id: string; data: UpdateProductDto },
  TContext
> => {
  const mutationKey = ['updateProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProduct>>,
    { id: string; data: UpdateProductDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateProduct(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProduct>>
>
export type UpdateProductMutationBody = UpdateProductDto
export type UpdateProductMutationError = ErrorResponseDto

/**
 * @summary Update product
 */
export const useUpdateProduct = <TError = ErrorResponseDto, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProduct>>,
      TError,
      { id: string; data: UpdateProductDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { id: string; data: UpdateProductDto },
  TContext
> => {
  const mutationOptions = getUpdateProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Deletes a product from the catalog
 * @summary Delete product
 */
export const deleteProduct = (id: string) => {
  return getAxiosInstance<MessageResponseDto>({
    url: `/api/v1/products/${id}`,
    method: 'DELETE',
  })
}

export const getDeleteProductMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProduct>>,
    TError,
    { id: string },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProduct>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteProduct(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProduct>>
>

export type DeleteProductMutationError = ErrorResponseDto

/**
 * @summary Delete product
 */
export const useDeleteProduct = <TError = ErrorResponseDto, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProduct>>,
      TError,
      { id: string },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
