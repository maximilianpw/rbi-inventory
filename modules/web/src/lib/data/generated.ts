/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * RBI Inventory API
 * REST API for RBI Inventory Management System
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import { getAxiosInstance } from './axios-client'
export interface ProfileResponseDto {
  [key: string]: unknown
}

export interface ErrorResponseDto {
  error: string
}

export interface SessionClaimsResponseDto {
  user_id: string
  session_id: string
  expires_at: number
  issued_at: number
}

/**
 * Parent category ID
 * @nullable
 */
export type CategoryWithChildrenResponseDtoParentId = {
  [key: string]: unknown
} | null

/**
 * Category description
 * @nullable
 */
export type CategoryWithChildrenResponseDtoDescription = {
  [key: string]: unknown
} | null

export interface CategoryWithChildrenResponseDto {
  /** Creation timestamp */
  created_at: string
  /** Last update timestamp */
  updated_at: string
  /** Unique identifier */
  id: string
  /** Category name */
  name: string
  /**
   * Parent category ID
   * @nullable
   */
  parent_id: CategoryWithChildrenResponseDtoParentId
  /**
   * Category description
   * @nullable
   */
  description: CategoryWithChildrenResponseDtoDescription
  /** Child categories */
  children: CategoryWithChildrenResponseDto[]
}

export interface CreateCategoryDto {
  /**
   * Category name
   * @minLength 1
   * @maxLength 100
   */
  name: string
  /**
   * Parent category ID
   * @nullable
   */
  parent_id?: string | null
  /**
   * Category description
   * @maxLength 500
   * @nullable
   */
  description?: string | null
}

/**
 * Parent category ID
 * @nullable
 */
export type CategoryResponseDtoParentId = { [key: string]: unknown } | null

/**
 * Category description
 * @nullable
 */
export type CategoryResponseDtoDescription = { [key: string]: unknown } | null

export interface CategoryResponseDto {
  /** Creation timestamp */
  created_at: string
  /** Last update timestamp */
  updated_at: string
  /** Unique identifier */
  id: string
  /** Category name */
  name: string
  /**
   * Parent category ID
   * @nullable
   */
  parent_id: CategoryResponseDtoParentId
  /**
   * Category description
   * @nullable
   */
  description: CategoryResponseDtoDescription
}

export interface UpdateCategoryDto {
  /**
   * Category name
   * @minLength 1
   * @maxLength 100
   */
  name?: string
  /**
   * Parent category ID
   * @nullable
   */
  parent_id?: string | null
  /**
   * Category description
   * @maxLength 500
   * @nullable
   */
  description?: string | null
}

export interface MessageResponseDto {
  message: string
}

/**
 * Parent category ID
 * @nullable
 */
export type CategorySummaryDtoParentId = { [key: string]: unknown } | null

export interface CategorySummaryDto {
  /** Category ID */
  id: string
  /** Category name */
  name: string
  /**
   * Parent category ID
   * @nullable
   */
  parent_id: CategorySummaryDtoParentId
}

export interface SupplierSummaryDto {
  /** Supplier ID */
  id: string
  /** Supplier name */
  name: string
}

/**
 * HTTP method for this link
 */
export type HateoasLinkMethod =
  (typeof HateoasLinkMethod)[keyof typeof HateoasLinkMethod]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HateoasLinkMethod = {
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  PATCH: 'PATCH',
  DELETE: 'DELETE',
} as const

export interface HateoasLink {
  /** The URL of the linked resource */
  href: string
  /** HTTP method for this link */
  method?: HateoasLinkMethod
}

export interface ProductLinksDto {
  /** Link to this product */
  self: HateoasLink
  /** Link to update this product */
  update: HateoasLink
  /** Link to delete this product */
  delete: HateoasLink
  /** Link to the product category */
  category: HateoasLink
}

/**
 * Deletion timestamp (for soft-deleted records)
 * @nullable
 */
export type ProductResponseDtoDeletedAt = { [key: string]: unknown } | null

/**
 * User ID who created the record
 * @nullable
 */
export type ProductResponseDtoCreatedBy = { [key: string]: unknown } | null

/**
 * User ID who last updated the record
 * @nullable
 */
export type ProductResponseDtoUpdatedBy = { [key: string]: unknown } | null

/**
 * User ID who deleted the record
 * @nullable
 */
export type ProductResponseDtoDeletedBy = { [key: string]: unknown } | null

/**
 * Product description
 * @nullable
 */
export type ProductResponseDtoDescription = { [key: string]: unknown } | null

/**
 * Nested category information
 * @nullable
 */
export type ProductResponseDtoCategory = CategorySummaryDto | null

/**
 * Brand ID
 * @nullable
 */
export type ProductResponseDtoBrandId = { [key: string]: unknown } | null

/**
 * Volume in milliliters
 * @nullable
 */
export type ProductResponseDtoVolumeMl = { [key: string]: unknown } | null

/**
 * Weight in kilograms
 * @nullable
 */
export type ProductResponseDtoWeightKg = { [key: string]: unknown } | null

/**
 * Dimensions in cm (format: LxWxH)
 * @nullable
 */
export type ProductResponseDtoDimensionsCm = { [key: string]: unknown } | null

/**
 * Standard cost
 * @nullable
 */
export type ProductResponseDtoStandardCost = { [key: string]: unknown } | null

/**
 * Standard price
 * @nullable
 */
export type ProductResponseDtoStandardPrice = { [key: string]: unknown } | null

/**
 * Markup percentage
 * @nullable
 */
export type ProductResponseDtoMarkupPercentage = {
  [key: string]: unknown
} | null

/**
 * Primary supplier ID
 * @nullable
 */
export type ProductResponseDtoPrimarySupplierId = {
  [key: string]: unknown
} | null

/**
 * Nested supplier information
 * @nullable
 */
export type ProductResponseDtoPrimarySupplier = SupplierSummaryDto | null

/**
 * Supplier SKU
 * @nullable
 */
export type ProductResponseDtoSupplierSku = { [key: string]: unknown } | null

/**
 * Additional notes
 * @nullable
 */
export type ProductResponseDtoNotes = { [key: string]: unknown } | null

export interface ProductResponseDto {
  /** Creation timestamp */
  created_at: string
  /** Last update timestamp */
  updated_at: string
  /**
   * Deletion timestamp (for soft-deleted records)
   * @nullable
   */
  deleted_at?: ProductResponseDtoDeletedAt
  /**
   * User ID who created the record
   * @nullable
   */
  created_by?: ProductResponseDtoCreatedBy
  /**
   * User ID who last updated the record
   * @nullable
   */
  updated_by?: ProductResponseDtoUpdatedBy
  /**
   * User ID who deleted the record
   * @nullable
   */
  deleted_by?: ProductResponseDtoDeletedBy
  /** Unique identifier */
  id: string
  /** Product SKU */
  sku: string
  /** Product name */
  name: string
  /**
   * Product description
   * @nullable
   */
  description: ProductResponseDtoDescription
  /** Category ID */
  category_id: string
  /**
   * Nested category information
   * @nullable
   */
  category?: ProductResponseDtoCategory
  /**
   * Brand ID
   * @nullable
   */
  brand_id: ProductResponseDtoBrandId
  /**
   * Volume in milliliters
   * @nullable
   */
  volume_ml: ProductResponseDtoVolumeMl
  /**
   * Weight in kilograms
   * @nullable
   */
  weight_kg: ProductResponseDtoWeightKg
  /**
   * Dimensions in cm (format: LxWxH)
   * @nullable
   */
  dimensions_cm: ProductResponseDtoDimensionsCm
  /**
   * Standard cost
   * @nullable
   */
  standard_cost: ProductResponseDtoStandardCost
  /**
   * Standard price
   * @nullable
   */
  standard_price: ProductResponseDtoStandardPrice
  /**
   * Markup percentage
   * @nullable
   */
  markup_percentage: ProductResponseDtoMarkupPercentage
  /** Reorder point threshold */
  reorder_point: number
  /**
   * Primary supplier ID
   * @nullable
   */
  primary_supplier_id: ProductResponseDtoPrimarySupplierId
  /**
   * Nested supplier information
   * @nullable
   */
  primary_supplier?: ProductResponseDtoPrimarySupplier
  /**
   * Supplier SKU
   * @nullable
   */
  supplier_sku: ProductResponseDtoSupplierSku
  /** Whether the product is active */
  is_active: boolean
  /** Whether the product is perishable */
  is_perishable: boolean
  /**
   * Additional notes
   * @nullable
   */
  notes: ProductResponseDtoNotes
  /** HATEOAS links */
  _links?: ProductLinksDto
}

export interface PaginationMeta {
  /** Current page number */
  page: number
  /** Number of items per page */
  limit: number
  /** Total number of items */
  total: number
  /** Total number of pages */
  total_pages: number
  /** Whether there is a next page */
  has_next: boolean
  /** Whether there is a previous page */
  has_previous: boolean
}

export interface PaginatedProductsResponseDto {
  /** List of products */
  data: ProductResponseDto[]
  /** Pagination metadata */
  meta: PaginationMeta
}

/**
 * Product description
 * @maxLength 1000
 * @nullable
 */
export type CreateProductDtoDescription = { [key: string]: unknown } | null

/**
 * Brand ID
 * @nullable
 */
export type CreateProductDtoBrandId = { [key: string]: unknown } | null

/**
 * Volume in milliliters
 * @minimum 1
 * @nullable
 */
export type CreateProductDtoVolumeMl = { [key: string]: unknown } | null

/**
 * Weight in kilograms
 * @minimum 0
 * @nullable
 */
export type CreateProductDtoWeightKg = { [key: string]: unknown } | null

/**
 * Dimensions in cm (format: LxWxH, e.g., 10x20x5)
 * @maxLength 50
 * @nullable
 */
export type CreateProductDtoDimensionsCm = { [key: string]: unknown } | null

/**
 * Standard cost
 * @minimum 0
 * @nullable
 */
export type CreateProductDtoStandardCost = { [key: string]: unknown } | null

/**
 * Standard price (must be >= standard_cost)
 * @minimum 0
 * @nullable
 */
export type CreateProductDtoStandardPrice = { [key: string]: unknown } | null

/**
 * Markup percentage
 * @minimum 0
 * @maximum 1000
 * @nullable
 */
export type CreateProductDtoMarkupPercentage = { [key: string]: unknown } | null

/**
 * Primary supplier ID
 * @nullable
 */
export type CreateProductDtoPrimarySupplierId = {
  [key: string]: unknown
} | null

/**
 * Supplier SKU
 * @maxLength 50
 * @nullable
 */
export type CreateProductDtoSupplierSku = { [key: string]: unknown } | null

/**
 * Additional notes
 * @maxLength 500
 * @nullable
 */
export type CreateProductDtoNotes = { [key: string]: unknown } | null

export interface CreateProductDto {
  /**
   * Product SKU
   * @minLength 1
   * @maxLength 50
   */
  sku: string
  /**
   * Product name
   * @minLength 1
   * @maxLength 200
   */
  name: string
  /**
   * Product description
   * @maxLength 1000
   * @nullable
   */
  description?: CreateProductDtoDescription
  /** Category ID */
  category_id: string
  /**
   * Brand ID
   * @nullable
   */
  brand_id?: CreateProductDtoBrandId
  /**
   * Volume in milliliters
   * @minimum 1
   * @nullable
   */
  volume_ml?: CreateProductDtoVolumeMl
  /**
   * Weight in kilograms
   * @minimum 0
   * @nullable
   */
  weight_kg?: CreateProductDtoWeightKg
  /**
   * Dimensions in cm (format: LxWxH, e.g., 10x20x5)
   * @maxLength 50
   * @nullable
   */
  dimensions_cm?: CreateProductDtoDimensionsCm
  /**
   * Standard cost
   * @minimum 0
   * @nullable
   */
  standard_cost?: CreateProductDtoStandardCost
  /**
   * Standard price (must be >= standard_cost)
   * @minimum 0
   * @nullable
   */
  standard_price?: CreateProductDtoStandardPrice
  /**
   * Markup percentage
   * @minimum 0
   * @maximum 1000
   * @nullable
   */
  markup_percentage?: CreateProductDtoMarkupPercentage
  /**
   * Reorder point threshold
   * @minimum 0
   */
  reorder_point: number
  /**
   * Primary supplier ID
   * @nullable
   */
  primary_supplier_id?: CreateProductDtoPrimarySupplierId
  /**
   * Supplier SKU
   * @maxLength 50
   * @nullable
   */
  supplier_sku?: CreateProductDtoSupplierSku
  /** Whether the product is active */
  is_active: boolean
  /** Whether the product is perishable */
  is_perishable: boolean
  /**
   * Additional notes
   * @maxLength 500
   * @nullable
   */
  notes?: CreateProductDtoNotes
}

export interface BulkCreateProductsDto {
  /**
   * Array of products to create
   * @minItems 1
   * @maxItems 100
   */
  products: CreateProductDto[]
}

export type BulkOperationResultDtoFailuresItem = {
  id?: string
  error?: string
}

export interface BulkOperationResultDto {
  /** Number of successfully processed items */
  success_count: number
  /** Number of failed items */
  failure_count: number
  /** IDs that were successfully processed */
  succeeded: string[]
  /** Details of failed operations */
  failures: BulkOperationResultDtoFailuresItem[]
}

/**
 * Product description
 * @maxLength 1000
 * @nullable
 */
export type UpdateProductDtoDescription = { [key: string]: unknown } | null

/**
 * Brand ID
 * @nullable
 */
export type UpdateProductDtoBrandId = { [key: string]: unknown } | null

/**
 * Volume in milliliters
 * @minimum 1
 * @nullable
 */
export type UpdateProductDtoVolumeMl = { [key: string]: unknown } | null

/**
 * Weight in kilograms
 * @minimum 0
 * @nullable
 */
export type UpdateProductDtoWeightKg = { [key: string]: unknown } | null

/**
 * Dimensions in cm (format: LxWxH, e.g., 10x20x5)
 * @maxLength 50
 * @nullable
 */
export type UpdateProductDtoDimensionsCm = { [key: string]: unknown } | null

/**
 * Standard cost
 * @minimum 0
 * @nullable
 */
export type UpdateProductDtoStandardCost = { [key: string]: unknown } | null

/**
 * Standard price (must be >= standard_cost)
 * @minimum 0
 * @nullable
 */
export type UpdateProductDtoStandardPrice = { [key: string]: unknown } | null

/**
 * Markup percentage
 * @minimum 0
 * @maximum 1000
 * @nullable
 */
export type UpdateProductDtoMarkupPercentage = { [key: string]: unknown } | null

/**
 * Primary supplier ID
 * @nullable
 */
export type UpdateProductDtoPrimarySupplierId = {
  [key: string]: unknown
} | null

/**
 * Supplier SKU
 * @maxLength 50
 * @nullable
 */
export type UpdateProductDtoSupplierSku = { [key: string]: unknown } | null

/**
 * Additional notes
 * @maxLength 500
 * @nullable
 */
export type UpdateProductDtoNotes = { [key: string]: unknown } | null

export interface UpdateProductDto {
  /**
   * Product SKU
   * @minLength 1
   * @maxLength 50
   */
  sku?: string
  /**
   * Product name
   * @minLength 1
   * @maxLength 200
   */
  name?: string
  /**
   * Product description
   * @maxLength 1000
   * @nullable
   */
  description?: UpdateProductDtoDescription
  /**
   * Category ID
   * @nullable
   */
  category_id?: string | null
  /**
   * Brand ID
   * @nullable
   */
  brand_id?: UpdateProductDtoBrandId
  /**
   * Volume in milliliters
   * @minimum 1
   * @nullable
   */
  volume_ml?: UpdateProductDtoVolumeMl
  /**
   * Weight in kilograms
   * @minimum 0
   * @nullable
   */
  weight_kg?: UpdateProductDtoWeightKg
  /**
   * Dimensions in cm (format: LxWxH, e.g., 10x20x5)
   * @maxLength 50
   * @nullable
   */
  dimensions_cm?: UpdateProductDtoDimensionsCm
  /**
   * Standard cost
   * @minimum 0
   * @nullable
   */
  standard_cost?: UpdateProductDtoStandardCost
  /**
   * Standard price (must be >= standard_cost)
   * @minimum 0
   * @nullable
   */
  standard_price?: UpdateProductDtoStandardPrice
  /**
   * Markup percentage
   * @minimum 0
   * @maximum 1000
   * @nullable
   */
  markup_percentage?: UpdateProductDtoMarkupPercentage
  /**
   * Reorder point threshold
   * @minimum 0
   * @nullable
   */
  reorder_point?: number | null
  /**
   * Primary supplier ID
   * @nullable
   */
  primary_supplier_id?: UpdateProductDtoPrimarySupplierId
  /**
   * Supplier SKU
   * @maxLength 50
   * @nullable
   */
  supplier_sku?: UpdateProductDtoSupplierSku
  /**
   * Whether the product is active
   * @nullable
   */
  is_active?: boolean | null
  /**
   * Whether the product is perishable
   * @nullable
   */
  is_perishable?: boolean | null
  /**
   * Additional notes
   * @maxLength 500
   * @nullable
   */
  notes?: UpdateProductDtoNotes
}

export interface BulkUpdateStatusDto {
  /**
   * Array of product IDs to update
   * @minItems 1
   * @maxItems 100
   */
  ids: string[]
  /** New active status */
  is_active: boolean
}

export interface BulkDeleteDto {
  /**
   * Array of product IDs to delete
   * @minItems 1
   * @maxItems 100
   */
  ids: string[]
  /** Permanently delete (hard delete) instead of soft delete */
  permanent?: boolean
}

export interface BulkRestoreDto {
  /**
   * Array of product IDs to restore
   * @minItems 1
   * @maxItems 100
   */
  ids: string[]
}

/**
 * User ID who performed the action
 * @nullable
 */
export type AuditLogResponseDtoUserId = { [key: string]: unknown } | null

/**
 * Action performed
 */
export type AuditLogResponseDtoAction =
  (typeof AuditLogResponseDtoAction)[keyof typeof AuditLogResponseDtoAction]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuditLogResponseDtoAction = {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  RESTORE: 'RESTORE',
  ADJUST_QUANTITY: 'ADJUST_QUANTITY',
  ADD_PHOTO: 'ADD_PHOTO',
  STATUS_CHANGE: 'STATUS_CHANGE',
} as const

/**
 * Type of entity affected
 */
export type AuditLogResponseDtoEntityType =
  (typeof AuditLogResponseDtoEntityType)[keyof typeof AuditLogResponseDtoEntityType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuditLogResponseDtoEntityType = {
  PRODUCT: 'PRODUCT',
  CATEGORY: 'CATEGORY',
  SUPPLIER: 'SUPPLIER',
  ORDER: 'ORDER',
  ORDER_ITEM: 'ORDER_ITEM',
  INVENTORY: 'INVENTORY',
  LOCATION: 'LOCATION',
  STOCK_MOVEMENT: 'STOCK_MOVEMENT',
  PHOTO: 'PHOTO',
} as const

/**
 * Changes made (before/after)
 * @nullable
 */
export type AuditLogResponseDtoChanges = { [key: string]: unknown } | null

/**
 * IP address of the requester
 * @nullable
 */
export type AuditLogResponseDtoIpAddress = { [key: string]: unknown } | null

/**
 * User agent of the requester
 * @nullable
 */
export type AuditLogResponseDtoUserAgent = { [key: string]: unknown } | null

export interface AuditLogResponseDto {
  /** Unique identifier */
  id: string
  /**
   * User ID who performed the action
   * @nullable
   */
  user_id: AuditLogResponseDtoUserId
  /** Action performed */
  action: AuditLogResponseDtoAction
  /** Type of entity affected */
  entity_type: AuditLogResponseDtoEntityType
  /** ID of the affected entity */
  entity_id: string
  /**
   * Changes made (before/after)
   * @nullable
   */
  changes: AuditLogResponseDtoChanges
  /**
   * IP address of the requester
   * @nullable
   */
  ip_address: AuditLogResponseDtoIpAddress
  /**
   * User agent of the requester
   * @nullable
   */
  user_agent: AuditLogResponseDtoUserAgent
  /** Creation timestamp */
  created_at: string
}

export interface PaginationMetaDto {
  /** Current page number */
  page: number
  /** Number of items per page */
  limit: number
  /** Total number of items */
  total: number
  /** Total number of pages */
  total_pages: number
  /** Whether there is a next page */
  has_next: boolean
  /** Whether there is a previous page */
  has_previous: boolean
}

export interface PaginatedAuditLogsResponseDto {
  /** Array of audit log entries */
  data: AuditLogResponseDto[]
  /** Pagination metadata */
  meta: PaginationMetaDto
}

export type HealthCheck200 = {
  status?: string
  timestamp?: string
}

export type ListProductsParams = {
  /**
   * Page number (1-based)
   * @minimum 1
   */
  page?: number
  /**
   * Number of items per page
   * @minimum 1
   * @maximum 100
   */
  limit?: number
  /**
   * Search term for name or SKU
   */
  search?: string
  /**
   * Filter by category ID
   */
  category_id?: string
  /**
   * Filter by brand ID
   */
  brand_id?: string
  /**
   * Filter by primary supplier ID
   */
  primary_supplier_id?: string
  /**
   * Filter by active status
   */
  is_active?: boolean
  /**
   * Filter by perishable status
   */
  is_perishable?: boolean
  /**
   * Minimum price filter
   * @minimum 0
   */
  min_price?: number
  /**
   * Maximum price filter
   * @minimum 0
   */
  max_price?: number
  /**
   * Include soft-deleted products
   */
  include_deleted?: boolean
  /**
   * Field to sort by
   */
  sort_by?: ListProductsSortBy
  /**
   * Sort order
   */
  sort_order?: ListProductsSortOrder
}

export type ListProductsSortBy =
  (typeof ListProductsSortBy)[keyof typeof ListProductsSortBy]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListProductsSortBy = {
  name: 'name',
  sku: 'sku',
  created_at: 'created_at',
  updated_at: 'updated_at',
  standard_price: 'standard_price',
  standard_cost: 'standard_cost',
  reorder_point: 'reorder_point',
} as const

export type ListProductsSortOrder =
  (typeof ListProductsSortOrder)[keyof typeof ListProductsSortOrder]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListProductsSortOrder = {
  ASC: 'ASC',
  DESC: 'DESC',
} as const

export type GetProductParams = {
  /**
   * Include soft-deleted products
   */
  include_deleted?: boolean
}

export type DeleteProductParams = {
  /**
   * Permanently delete instead of soft delete
   */
  permanent?: boolean
}

export type ListAuditLogsParams = {
  /**
   * Page number (1-based)
   * @minimum 1
   */
  page?: number
  /**
   * Number of items per page
   * @minimum 1
   * @maximum 100
   */
  limit?: number
  /**
   * Filter by entity type
   */
  entity_type?: ListAuditLogsEntityType
  /**
   * Filter by entity ID
   */
  entity_id?: string
  /**
   * Filter by user ID
   */
  user_id?: string
  /**
   * Filter by action
   */
  action?: ListAuditLogsAction
  /**
   * Filter from date (ISO 8601)
   */
  from_date?: string
  /**
   * Filter to date (ISO 8601)
   */
  to_date?: string
}

export type ListAuditLogsEntityType =
  (typeof ListAuditLogsEntityType)[keyof typeof ListAuditLogsEntityType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListAuditLogsEntityType = {
  PRODUCT: 'PRODUCT',
  CATEGORY: 'CATEGORY',
  SUPPLIER: 'SUPPLIER',
  ORDER: 'ORDER',
  ORDER_ITEM: 'ORDER_ITEM',
  INVENTORY: 'INVENTORY',
  LOCATION: 'LOCATION',
  STOCK_MOVEMENT: 'STOCK_MOVEMENT',
  PHOTO: 'PHOTO',
} as const

export type ListAuditLogsAction =
  (typeof ListAuditLogsAction)[keyof typeof ListAuditLogsAction]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListAuditLogsAction = {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  RESTORE: 'RESTORE',
  ADJUST_QUANTITY: 'ADJUST_QUANTITY',
  ADD_PHOTO: 'ADD_PHOTO',
  STATUS_CHANGE: 'STATUS_CHANGE',
} as const

/**
 * Returns the health status of the API
 * @summary Health check endpoint
 */
export const healthCheck = (signal?: AbortSignal) => {
  return getAxiosInstance<HealthCheck200>({
    url: `/health-check`,
    method: 'GET',
    signal,
  })
}

export const getHealthCheckQueryKey = () => {
  return [`/health-check`] as const
}

export const getHealthCheckQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getHealthCheckQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({
    signal,
  }) => healthCheck(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheck>>
>
export type HealthCheckQueryError = unknown

export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Health check endpoint
 */

export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves the current user profile from Clerk
 * @summary Get user profile
 */
export const getProfile = (signal?: AbortSignal) => {
  return getAxiosInstance<ProfileResponseDto>({
    url: `/auth/auth/profile`,
    method: 'GET',
    signal,
  })
}

export const getGetProfileQueryKey = () => {
  return [`/auth/auth/profile`] as const
}

export const getGetProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProfileQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfile>>> = ({
    signal,
  }) => getProfile(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProfileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProfile>>
>
export type GetProfileQueryError = ErrorResponseDto

export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          Awaited<ReturnType<typeof getProfile>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          Awaited<ReturnType<typeof getProfile>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get user profile
 */

export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProfileQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves the current session JWT claims
 * @summary Get session claims
 */
export const getSessionClaims = (signal?: AbortSignal) => {
  return getAxiosInstance<SessionClaimsResponseDto>({
    url: `/auth/auth/session-claims`,
    method: 'GET',
    signal,
  })
}

export const getGetSessionClaimsQueryKey = () => {
  return [`/auth/auth/session-claims`] as const
}

export const getGetSessionClaimsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSessionClaims>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetSessionClaimsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSessionClaims>>
  > = ({ signal }) => getSessionClaims(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSessionClaims>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionClaimsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSessionClaims>>
>
export type GetSessionClaimsQueryError = ErrorResponseDto

export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionClaims>>,
          TError,
          Awaited<ReturnType<typeof getSessionClaims>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionClaims>>,
          TError,
          Awaited<ReturnType<typeof getSessionClaims>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get session claims
 */

export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetSessionClaimsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves all product categories with their child categories
 * @summary List all categories
 */
export const listCategories = (signal?: AbortSignal) => {
  return getAxiosInstance<CategoryWithChildrenResponseDto[]>({
    url: `/categories`,
    method: 'GET',
    signal,
  })
}

export const getListCategoriesQueryKey = () => {
  return [`/categories`] as const
}

export const getListCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListCategoriesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listCategories>>> = ({
    signal,
  }) => listCategories(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListCategoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof listCategories>>
>
export type ListCategoriesQueryError = ErrorResponseDto

export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCategories>>,
          TError,
          Awaited<ReturnType<typeof listCategories>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCategories>>,
          TError,
          Awaited<ReturnType<typeof listCategories>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List all categories
 */

export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListCategoriesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Creates a new product category
 * @summary Create category
 */
export const createCategory = (
  createCategoryDto: CreateCategoryDto,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<CategoryResponseDto>({
    url: `/categories`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createCategoryDto,
    signal,
  })
}

export const getCreateCategoryMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCategory>>,
    TError,
    { data: CreateCategoryDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: CreateCategoryDto },
  TContext
> => {
  const mutationKey = ['createCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCategory>>,
    { data: CreateCategoryDto }
  > = (props) => {
    const { data } = props ?? {}

    return createCategory(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCategory>>
>
export type CreateCategoryMutationBody = CreateCategoryDto
export type CreateCategoryMutationError = ErrorResponseDto

/**
 * @summary Create category
 */
export const useCreateCategory = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCategory>>,
      TError,
      { data: CreateCategoryDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: CreateCategoryDto },
  TContext
> => {
  const mutationOptions = getCreateCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Updates an existing product category
 * @summary Update category
 */
export const updateCategory = (
  id: string,
  updateCategoryDto: UpdateCategoryDto,
) => {
  return getAxiosInstance<CategoryResponseDto>({
    url: `/categories/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateCategoryDto,
  })
}

export const getUpdateCategoryMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCategory>>,
    TError,
    { id: string; data: UpdateCategoryDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { id: string; data: UpdateCategoryDto },
  TContext
> => {
  const mutationKey = ['updateCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCategory>>,
    { id: string; data: UpdateCategoryDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateCategory(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCategory>>
>
export type UpdateCategoryMutationBody = UpdateCategoryDto
export type UpdateCategoryMutationError = ErrorResponseDto

/**
 * @summary Update category
 */
export const useUpdateCategory = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateCategory>>,
      TError,
      { id: string; data: UpdateCategoryDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { id: string; data: UpdateCategoryDto },
  TContext
> => {
  const mutationOptions = getUpdateCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Deletes a product category
 * @summary Delete category
 */
export const deleteCategory = (id: string) => {
  return getAxiosInstance<MessageResponseDto>({
    url: `/categories/${id}`,
    method: 'DELETE',
  })
}

export const getDeleteCategoryMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCategory>>,
    TError,
    { id: string },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteCategory>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCategory>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteCategory(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCategory>>
>

export type DeleteCategoryMutationError = ErrorResponseDto

/**
 * @summary Delete category
 */
export const useDeleteCategory = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteCategory>>,
      TError,
      { id: string },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteCategory>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary List products with pagination and filtering
 */
export const listProducts = (
  params?: ListProductsParams,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<PaginatedProductsResponseDto>({
    url: `/products`,
    method: 'GET',
    params,
    signal,
  })
}

export const getListProductsQueryKey = (params?: ListProductsParams) => {
  return [`/products`, ...(params ? [params] : [])] as const
}

export const getListProductsQueryOptions = <
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  params?: ListProductsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListProductsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listProducts>>> = ({
    signal,
  }) => listProducts(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListProductsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listProducts>>
>
export type ListProductsQueryError = ErrorResponseDto

export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  params: undefined | ListProductsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProducts>>,
          TError,
          Awaited<ReturnType<typeof listProducts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  params?: ListProductsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProducts>>,
          TError,
          Awaited<ReturnType<typeof listProducts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  params?: ListProductsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List products with pagination and filtering
 */

export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  params?: ListProductsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListProductsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create product
 */
export const createProduct = (
  createProductDto: CreateProductDto,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponseDto>({
    url: `/products`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createProductDto,
    signal,
  })
}

export const getCreateProductMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProduct>>,
    TError,
    { data: CreateProductDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { data: CreateProductDto },
  TContext
> => {
  const mutationKey = ['createProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProduct>>,
    { data: CreateProductDto }
  > = (props) => {
    const { data } = props ?? {}

    return createProduct(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProduct>>
>
export type CreateProductMutationBody = CreateProductDto
export type CreateProductMutationError = ErrorResponseDto

/**
 * @summary Create product
 */
export const useCreateProduct = <TError = ErrorResponseDto, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProduct>>,
      TError,
      { data: CreateProductDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { data: CreateProductDto },
  TContext
> => {
  const mutationOptions = getCreateProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary List all products without pagination
 */
export const listAllProducts = (signal?: AbortSignal) => {
  return getAxiosInstance<ProductResponseDto[]>({
    url: `/products/all`,
    method: 'GET',
    signal,
  })
}

export const getListAllProductsQueryKey = () => {
  return [`/products/all`] as const
}

export const getListAllProductsQueryOptions = <
  TData = Awaited<ReturnType<typeof listAllProducts>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listAllProducts>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListAllProductsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listAllProducts>>> = ({
    signal,
  }) => listAllProducts(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listAllProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAllProductsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listAllProducts>>
>
export type ListAllProductsQueryError = ErrorResponseDto

export function useListAllProducts<
  TData = Awaited<ReturnType<typeof listAllProducts>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllProducts>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllProducts>>,
          TError,
          Awaited<ReturnType<typeof listAllProducts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAllProducts<
  TData = Awaited<ReturnType<typeof listAllProducts>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllProducts>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllProducts>>,
          TError,
          Awaited<ReturnType<typeof listAllProducts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAllProducts<
  TData = Awaited<ReturnType<typeof listAllProducts>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllProducts>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List all products without pagination
 */

export function useListAllProducts<
  TData = Awaited<ReturnType<typeof listAllProducts>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllProducts>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListAllProductsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get product by ID
 */
export const getProduct = (
  id: string,
  params?: GetProductParams,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponseDto>({
    url: `/products/${id}`,
    method: 'GET',
    params,
    signal,
  })
}

export const getGetProductQueryKey = (
  id?: string,
  params?: GetProductParams,
) => {
  return [`/products/${id}`, ...(params ? [params] : [])] as const
}

export const getGetProductQueryOptions = <
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  params?: GetProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProductQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProduct>>> = ({
    signal,
  }) => getProduct(id, params, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProduct>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProduct>>
>
export type GetProductQueryError = ErrorResponseDto

export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  params: undefined | GetProductParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  params?: GetProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  params?: GetProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get product by ID
 */

export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  params?: GetProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProductQueryOptions(id, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update product
 */
export const updateProduct = (
  id: string,
  updateProductDto: UpdateProductDto,
) => {
  return getAxiosInstance<ProductResponseDto>({
    url: `/products/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateProductDto,
  })
}

export const getUpdateProductMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProduct>>,
    TError,
    { id: string; data: UpdateProductDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { id: string; data: UpdateProductDto },
  TContext
> => {
  const mutationKey = ['updateProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProduct>>,
    { id: string; data: UpdateProductDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateProduct(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProduct>>
>
export type UpdateProductMutationBody = UpdateProductDto
export type UpdateProductMutationError = ErrorResponseDto

/**
 * @summary Update product
 */
export const useUpdateProduct = <TError = ErrorResponseDto, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProduct>>,
      TError,
      { id: string; data: UpdateProductDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { id: string; data: UpdateProductDto },
  TContext
> => {
  const mutationOptions = getUpdateProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Delete product
 */
export const deleteProduct = (id: string, params?: DeleteProductParams) => {
  return getAxiosInstance<MessageResponseDto>({
    url: `/products/${id}`,
    method: 'DELETE',
    params,
  })
}

export const getDeleteProductMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProduct>>,
    TError,
    { id: string; params?: DeleteProductParams },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { id: string; params?: DeleteProductParams },
  TContext
> => {
  const mutationKey = ['deleteProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProduct>>,
    { id: string; params?: DeleteProductParams }
  > = (props) => {
    const { id, params } = props ?? {}

    return deleteProduct(id, params)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProduct>>
>

export type DeleteProductMutationError = ErrorResponseDto

/**
 * @summary Delete product
 */
export const useDeleteProduct = <TError = ErrorResponseDto, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProduct>>,
      TError,
      { id: string; params?: DeleteProductParams },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { id: string; params?: DeleteProductParams },
  TContext
> => {
  const mutationOptions = getDeleteProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Get products by category
 */
export const getProductsByCategory = (
  categoryId: string,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponseDto[]>({
    url: `/products/category/${categoryId}`,
    method: 'GET',
    signal,
  })
}

export const getGetProductsByCategoryQueryKey = (categoryId?: string) => {
  return [`/products/category/${categoryId}`] as const
}

export const getGetProductsByCategoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetProductsByCategoryQueryKey(categoryId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProductsByCategory>>
  > = ({ signal }) => getProductsByCategory(categoryId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!categoryId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductsByCategory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductsByCategoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProductsByCategory>>
>
export type GetProductsByCategoryQueryError = ErrorResponseDto

export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get products by category
 */

export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProductsByCategoryQueryOptions(categoryId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get products by category tree
 */
export const getProductsByCategoryTree = (
  categoryId: string,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponseDto[]>({
    url: `/products/category/${categoryId}/tree`,
    method: 'GET',
    signal,
  })
}

export const getGetProductsByCategoryTreeQueryKey = (categoryId?: string) => {
  return [`/products/category/${categoryId}/tree`] as const
}

export const getGetProductsByCategoryTreeQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetProductsByCategoryTreeQueryKey(categoryId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProductsByCategoryTree>>
  > = ({ signal }) => getProductsByCategoryTree(categoryId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!categoryId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductsByCategoryTree>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductsByCategoryTreeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProductsByCategoryTree>>
>
export type GetProductsByCategoryTreeQueryError = ErrorResponseDto

export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategoryTree>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategoryTree>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategoryTree>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategoryTree>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get products by category tree
 */

export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProductsByCategoryTreeQueryOptions(
    categoryId,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Bulk create products
 */
export const bulkCreateProducts = (
  bulkCreateProductsDto: BulkCreateProductsDto,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<BulkOperationResultDto>({
    url: `/products/bulk`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: bulkCreateProductsDto,
    signal,
  })
}

export const getBulkCreateProductsMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bulkCreateProducts>>,
    TError,
    { data: BulkCreateProductsDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof bulkCreateProducts>>,
  TError,
  { data: BulkCreateProductsDto },
  TContext
> => {
  const mutationKey = ['bulkCreateProducts']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkCreateProducts>>,
    { data: BulkCreateProductsDto }
  > = (props) => {
    const { data } = props ?? {}

    return bulkCreateProducts(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type BulkCreateProductsMutationResult = NonNullable<
  Awaited<ReturnType<typeof bulkCreateProducts>>
>
export type BulkCreateProductsMutationBody = BulkCreateProductsDto
export type BulkCreateProductsMutationError = ErrorResponseDto

/**
 * @summary Bulk create products
 */
export const useBulkCreateProducts = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bulkCreateProducts>>,
      TError,
      { data: BulkCreateProductsDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof bulkCreateProducts>>,
  TError,
  { data: BulkCreateProductsDto },
  TContext
> => {
  const mutationOptions = getBulkCreateProductsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Bulk delete products
 */
export const bulkDeleteProducts = (bulkDeleteDto: BulkDeleteDto) => {
  return getAxiosInstance<BulkOperationResultDto>({
    url: `/products/bulk`,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    data: bulkDeleteDto,
  })
}

export const getBulkDeleteProductsMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bulkDeleteProducts>>,
    TError,
    { data: BulkDeleteDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof bulkDeleteProducts>>,
  TError,
  { data: BulkDeleteDto },
  TContext
> => {
  const mutationKey = ['bulkDeleteProducts']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkDeleteProducts>>,
    { data: BulkDeleteDto }
  > = (props) => {
    const { data } = props ?? {}

    return bulkDeleteProducts(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type BulkDeleteProductsMutationResult = NonNullable<
  Awaited<ReturnType<typeof bulkDeleteProducts>>
>
export type BulkDeleteProductsMutationBody = BulkDeleteDto
export type BulkDeleteProductsMutationError = ErrorResponseDto

/**
 * @summary Bulk delete products
 */
export const useBulkDeleteProducts = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bulkDeleteProducts>>,
      TError,
      { data: BulkDeleteDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof bulkDeleteProducts>>,
  TError,
  { data: BulkDeleteDto },
  TContext
> => {
  const mutationOptions = getBulkDeleteProductsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Bulk update product status
 */
export const bulkUpdateProductStatus = (
  bulkUpdateStatusDto: BulkUpdateStatusDto,
) => {
  return getAxiosInstance<BulkOperationResultDto>({
    url: `/products/bulk/status`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: bulkUpdateStatusDto,
  })
}

export const getBulkUpdateProductStatusMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bulkUpdateProductStatus>>,
    TError,
    { data: BulkUpdateStatusDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof bulkUpdateProductStatus>>,
  TError,
  { data: BulkUpdateStatusDto },
  TContext
> => {
  const mutationKey = ['bulkUpdateProductStatus']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkUpdateProductStatus>>,
    { data: BulkUpdateStatusDto }
  > = (props) => {
    const { data } = props ?? {}

    return bulkUpdateProductStatus(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type BulkUpdateProductStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof bulkUpdateProductStatus>>
>
export type BulkUpdateProductStatusMutationBody = BulkUpdateStatusDto
export type BulkUpdateProductStatusMutationError = ErrorResponseDto

/**
 * @summary Bulk update product status
 */
export const useBulkUpdateProductStatus = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bulkUpdateProductStatus>>,
      TError,
      { data: BulkUpdateStatusDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof bulkUpdateProductStatus>>,
  TError,
  { data: BulkUpdateStatusDto },
  TContext
> => {
  const mutationOptions = getBulkUpdateProductStatusMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Restore deleted product
 */
export const restoreProduct = (id: string) => {
  return getAxiosInstance<ProductResponseDto>({
    url: `/products/${id}/restore`,
    method: 'PATCH',
  })
}

export const getRestoreProductMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof restoreProduct>>,
    TError,
    { id: string },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof restoreProduct>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['restoreProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof restoreProduct>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return restoreProduct(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type RestoreProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof restoreProduct>>
>

export type RestoreProductMutationError = ErrorResponseDto

/**
 * @summary Restore deleted product
 */
export const useRestoreProduct = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof restoreProduct>>,
      TError,
      { id: string },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof restoreProduct>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getRestoreProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Bulk restore products
 */
export const bulkRestoreProducts = (bulkRestoreDto: BulkRestoreDto) => {
  return getAxiosInstance<BulkOperationResultDto>({
    url: `/products/bulk/restore`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: bulkRestoreDto,
  })
}

export const getBulkRestoreProductsMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bulkRestoreProducts>>,
    TError,
    { data: BulkRestoreDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof bulkRestoreProducts>>,
  TError,
  { data: BulkRestoreDto },
  TContext
> => {
  const mutationKey = ['bulkRestoreProducts']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkRestoreProducts>>,
    { data: BulkRestoreDto }
  > = (props) => {
    const { data } = props ?? {}

    return bulkRestoreProducts(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type BulkRestoreProductsMutationResult = NonNullable<
  Awaited<ReturnType<typeof bulkRestoreProducts>>
>
export type BulkRestoreProductsMutationBody = BulkRestoreDto
export type BulkRestoreProductsMutationError = ErrorResponseDto

/**
 * @summary Bulk restore products
 */
export const useBulkRestoreProducts = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bulkRestoreProducts>>,
      TError,
      { data: BulkRestoreDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof bulkRestoreProducts>>,
  TError,
  { data: BulkRestoreDto },
  TContext
> => {
  const mutationOptions = getBulkRestoreProductsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary List audit logs with pagination and filtering
 */
export const listAuditLogs = (
  params?: ListAuditLogsParams,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<PaginatedAuditLogsResponseDto>({
    url: `/audit-logs`,
    method: 'GET',
    params,
    signal,
  })
}

export const getListAuditLogsQueryKey = (params?: ListAuditLogsParams) => {
  return [`/audit-logs`, ...(params ? [params] : [])] as const
}

export const getListAuditLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof listAuditLogs>>,
  TError = ErrorResponseDto,
>(
  params?: ListAuditLogsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAuditLogs>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListAuditLogsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listAuditLogs>>> = ({
    signal,
  }) => listAuditLogs(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listAuditLogs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAuditLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listAuditLogs>>
>
export type ListAuditLogsQueryError = ErrorResponseDto

export function useListAuditLogs<
  TData = Awaited<ReturnType<typeof listAuditLogs>>,
  TError = ErrorResponseDto,
>(
  params: undefined | ListAuditLogsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAuditLogs>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAuditLogs>>,
          TError,
          Awaited<ReturnType<typeof listAuditLogs>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAuditLogs<
  TData = Awaited<ReturnType<typeof listAuditLogs>>,
  TError = ErrorResponseDto,
>(
  params?: ListAuditLogsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAuditLogs>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAuditLogs>>,
          TError,
          Awaited<ReturnType<typeof listAuditLogs>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAuditLogs<
  TData = Awaited<ReturnType<typeof listAuditLogs>>,
  TError = ErrorResponseDto,
>(
  params?: ListAuditLogsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAuditLogs>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List audit logs with pagination and filtering
 */

export function useListAuditLogs<
  TData = Awaited<ReturnType<typeof listAuditLogs>>,
  TError = ErrorResponseDto,
>(
  params?: ListAuditLogsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAuditLogs>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListAuditLogsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get audit log by ID
 */
export const getAuditLog = (id: string, signal?: AbortSignal) => {
  return getAxiosInstance<AuditLogResponseDto>({
    url: `/audit-logs/${id}`,
    method: 'GET',
    signal,
  })
}

export const getGetAuditLogQueryKey = (id?: string) => {
  return [`/audit-logs/${id}`] as const
}

export const getGetAuditLogQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuditLog>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuditLog>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAuditLogQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuditLog>>> = ({
    signal,
  }) => getAuditLog(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuditLog>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuditLogQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuditLog>>
>
export type GetAuditLogQueryError = ErrorResponseDto

export function useGetAuditLog<
  TData = Awaited<ReturnType<typeof getAuditLog>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuditLog>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuditLog>>,
          TError,
          Awaited<ReturnType<typeof getAuditLog>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAuditLog<
  TData = Awaited<ReturnType<typeof getAuditLog>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuditLog>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuditLog>>,
          TError,
          Awaited<ReturnType<typeof getAuditLog>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAuditLog<
  TData = Awaited<ReturnType<typeof getAuditLog>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuditLog>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get audit log by ID
 */

export function useGetAuditLog<
  TData = Awaited<ReturnType<typeof getAuditLog>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuditLog>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetAuditLogQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get audit history for a specific entity
 */
export const getEntityAuditHistory = (
  entityType:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId: string,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<AuditLogResponseDto[]>({
    url: `/audit-logs/entity/${entityType}/${entityId}`,
    method: 'GET',
    signal,
  })
}

export const getGetEntityAuditHistoryQueryKey = (
  entityType?:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId?: string,
) => {
  return [`/audit-logs/entity/${entityType}/${entityId}`] as const
}

export const getGetEntityAuditHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getEntityAuditHistory>>,
  TError = ErrorResponseDto,
>(
  entityType:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEntityAuditHistory>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetEntityAuditHistoryQueryKey(entityType, entityId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEntityAuditHistory>>
  > = ({ signal }) => getEntityAuditHistory(entityType, entityId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!(entityType && entityId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getEntityAuditHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEntityAuditHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEntityAuditHistory>>
>
export type GetEntityAuditHistoryQueryError = ErrorResponseDto

export function useGetEntityAuditHistory<
  TData = Awaited<ReturnType<typeof getEntityAuditHistory>>,
  TError = ErrorResponseDto,
>(
  entityType:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEntityAuditHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEntityAuditHistory>>,
          TError,
          Awaited<ReturnType<typeof getEntityAuditHistory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetEntityAuditHistory<
  TData = Awaited<ReturnType<typeof getEntityAuditHistory>>,
  TError = ErrorResponseDto,
>(
  entityType:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEntityAuditHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEntityAuditHistory>>,
          TError,
          Awaited<ReturnType<typeof getEntityAuditHistory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetEntityAuditHistory<
  TData = Awaited<ReturnType<typeof getEntityAuditHistory>>,
  TError = ErrorResponseDto,
>(
  entityType:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEntityAuditHistory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get audit history for a specific entity
 */

export function useGetEntityAuditHistory<
  TData = Awaited<ReturnType<typeof getEntityAuditHistory>>,
  TError = ErrorResponseDto,
>(
  entityType:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEntityAuditHistory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetEntityAuditHistoryQueryOptions(
    entityType,
    entityId,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get audit history for a specific user
 */
export const getUserAuditHistory = (userId: string, signal?: AbortSignal) => {
  return getAxiosInstance<AuditLogResponseDto[]>({
    url: `/audit-logs/user/${userId}`,
    method: 'GET',
    signal,
  })
}

export const getGetUserAuditHistoryQueryKey = (userId?: string) => {
  return [`/audit-logs/user/${userId}`] as const
}

export const getGetUserAuditHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserAuditHistory>>,
  TError = ErrorResponseDto,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserAuditHistory>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetUserAuditHistoryQueryKey(userId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserAuditHistory>>
  > = ({ signal }) => getUserAuditHistory(userId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserAuditHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserAuditHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserAuditHistory>>
>
export type GetUserAuditHistoryQueryError = ErrorResponseDto

export function useGetUserAuditHistory<
  TData = Awaited<ReturnType<typeof getUserAuditHistory>>,
  TError = ErrorResponseDto,
>(
  userId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserAuditHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserAuditHistory>>,
          TError,
          Awaited<ReturnType<typeof getUserAuditHistory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetUserAuditHistory<
  TData = Awaited<ReturnType<typeof getUserAuditHistory>>,
  TError = ErrorResponseDto,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserAuditHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserAuditHistory>>,
          TError,
          Awaited<ReturnType<typeof getUserAuditHistory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetUserAuditHistory<
  TData = Awaited<ReturnType<typeof getUserAuditHistory>>,
  TError = ErrorResponseDto,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserAuditHistory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get audit history for a specific user
 */

export function useGetUserAuditHistory<
  TData = Awaited<ReturnType<typeof getUserAuditHistory>>,
  TError = ErrorResponseDto,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserAuditHistory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetUserAuditHistoryQueryOptions(userId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}
