/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * RBI Inventory API
 * REST API for RBI Inventory Management System
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'

import { getAxiosInstance } from './axios-client'

import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

export type Uuid = string

export interface ErrorResponse {
  error: string
}

export interface MessageResponse {
  message: string
}

export type UserResponseRole =
  (typeof UserResponseRole)[keyof typeof UserResponseRole]

export const UserResponseRole = {
  ADMIN: 'ADMIN',
  WAREHOUSE_MANAGER: 'WAREHOUSE_MANAGER',
  PICKER: 'PICKER',
  SALES: 'SALES',
} as const

export interface UserResponse {
  id: Uuid
  name: string
  email: string
  role: UserResponseRole
  is_active: boolean
  /** @nullable */
  last_login?: string | null
  created_at: string
  updated_at: string
}

export type CreateUserRequestRole =
  (typeof CreateUserRequestRole)[keyof typeof CreateUserRequestRole]

export const CreateUserRequestRole = {
  ADMIN: 'ADMIN',
  WAREHOUSE_MANAGER: 'WAREHOUSE_MANAGER',
  PICKER: 'PICKER',
  SALES: 'SALES',
} as const

export interface CreateUserRequest {
  /**
   * @minLength 2
   * @maxLength 100
   */
  name: string
  email: string
  role: CreateUserRequestRole
}

export type UpdateUserRequestRole =
  (typeof UpdateUserRequestRole)[keyof typeof UpdateUserRequestRole]

export const UpdateUserRequestRole = {
  ADMIN: 'ADMIN',
  WAREHOUSE_MANAGER: 'WAREHOUSE_MANAGER',
  PICKER: 'PICKER',
  SALES: 'SALES',
} as const

export interface UpdateUserRequest {
  /**
   * @minLength 2
   * @maxLength 100
   */
  name?: string
  email?: string
  role?: UpdateUserRequestRole
  is_active?: boolean
}

export interface CategoryResponse {
  id: Uuid
  name: string
  /** @nullable */
  parent_id?: Uuid
  /** @nullable */
  description?: string | null
  created_at: string
  updated_at: string
}

export interface CategoryWithChildrenResponse {
  id: Uuid
  name: string
  /** @nullable */
  parent_id?: Uuid
  /** @nullable */
  description?: string | null
  children: CategoryWithChildrenResponse[]
  created_at: string
  updated_at: string
}

export interface CreateCategoryRequest {
  /**
   * @minLength 1
   * @maxLength 100
   */
  name: string
  /** @nullable */
  parent_id?: Uuid
  /**
   * @maxLength 500
   * @nullable
   */
  description?: string | null
}

export interface UpdateCategoryRequest {
  /**
   * @minLength 1
   * @maxLength 100
   */
  name?: string
  /** @nullable */
  parent_id?: Uuid
  /**
   * @maxLength 500
   * @nullable
   */
  description?: string | null
}

export interface ProductResponse {
  id: Uuid
  sku: string
  name: string
  /** @nullable */
  description?: string | null
  category_id: Uuid
  /** @nullable */
  brand_id?: Uuid
  /** @nullable */
  volume_ml?: number | null
  /** @nullable */
  weight_kg?: number | null
  /** @nullable */
  dimensions_cm?: string | null
  /** @nullable */
  standard_cost?: number | null
  /** @nullable */
  standard_price?: number | null
  /** @nullable */
  markup_percentage?: number | null
  reorder_point: number
  /** @nullable */
  primary_supplier_id?: Uuid
  /** @nullable */
  supplier_sku?: string | null
  is_active: boolean
  is_perishable: boolean
  /** @nullable */
  notes?: string | null
  created_at: string
  updated_at: string
}

export interface CreateProductRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  sku: string
  /**
   * @minLength 1
   * @maxLength 200
   */
  name: string
  /**
   * @maxLength 1000
   * @nullable
   */
  description?: string | null
  category_id: Uuid
  /** @nullable */
  brand_id?: Uuid
  /**
   * @minimum 1
   * @nullable
   */
  volume_ml?: number | null
  /**
   * @minimum 0
   * @nullable
   */
  weight_kg?: number | null
  /**
   * @maxLength 50
   * @nullable
   */
  dimensions_cm?: string | null
  /**
   * @minimum 0
   * @nullable
   */
  standard_cost?: number | null
  /**
   * @minimum 0
   * @nullable
   */
  standard_price?: number | null
  /**
   * @minimum 0
   * @maximum 1000
   * @nullable
   */
  markup_percentage?: number | null
  /** @minimum 0 */
  reorder_point: number
  /** @nullable */
  primary_supplier_id?: Uuid
  /**
   * @maxLength 50
   * @nullable
   */
  supplier_sku?: string | null
  is_active: boolean
  is_perishable: boolean
  /**
   * @maxLength 500
   * @nullable
   */
  notes?: string | null
}

export interface UpdateProductRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  sku?: string
  /**
   * @minLength 1
   * @maxLength 200
   */
  name?: string
  /**
   * @maxLength 1000
   * @nullable
   */
  description?: string | null
  /** @nullable */
  category_id?: Uuid
  /** @nullable */
  brand_id?: Uuid
  /**
   * @minimum 1
   * @nullable
   */
  volume_ml?: number | null
  /**
   * @minimum 0
   * @nullable
   */
  weight_kg?: number | null
  /**
   * @maxLength 50
   * @nullable
   */
  dimensions_cm?: string | null
  /**
   * @minimum 0
   * @nullable
   */
  standard_cost?: number | null
  /**
   * @minimum 0
   * @nullable
   */
  standard_price?: number | null
  /**
   * @minimum 0
   * @maximum 1000
   * @nullable
   */
  markup_percentage?: number | null
  /**
   * @minimum 0
   * @nullable
   */
  reorder_point?: number | null
  /** @nullable */
  primary_supplier_id?: Uuid
  /**
   * @maxLength 50
   * @nullable
   */
  supplier_sku?: string | null
  /** @nullable */
  is_active?: boolean | null
  /** @nullable */
  is_perishable?: boolean | null
  /**
   * @maxLength 500
   * @nullable
   */
  notes?: string | null
}

/**
 * Clerk user profile data
 */
export type ProfileResponse = Record<string, unknown>

export interface SessionClaimsResponse {
  user_id: string
  session_id: string
  expires_at: number
  issued_at: number
}

export interface HealthCheck200 {
  status?: string
}

export interface ListUsersParams {
  /**
   * Filter users by role
   */
  role?: ListUsersRole
  /**
   * Filter users by active status
   */
  active?: boolean
}

export type ListUsersRole = (typeof ListUsersRole)[keyof typeof ListUsersRole]

export const ListUsersRole = {
  ADMIN: 'ADMIN',
  WAREHOUSE_MANAGER: 'WAREHOUSE_MANAGER',
  PICKER: 'PICKER',
  SALES: 'SALES',
} as const

export interface SearchUsersParams {
  /**
   * Search query
   */
  q: string
}

/**
 * Returns the health status of the API
 * @summary Health check endpoint
 */
export const healthCheck = async (signal?: AbortSignal) => {
  return getAxiosInstance<HealthCheck200>({
    url: `/health-check`,
    method: 'GET',
    signal,
  })
}

export const getHealthCheckQueryKey = () => {
  return [`/health-check`] as const
}

export const getHealthCheckQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getHealthCheckQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof healthCheck>>
  > = async ({ signal }) => healthCheck(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheck>>
>
export type HealthCheckQueryError = unknown

export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Health check endpoint
 */

export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Returns the authenticated user's profile from Clerk
 * @summary Get user profile
 */
export const getProfile = async (signal?: AbortSignal) => {
  return getAxiosInstance<ProfileResponse>({
    url: `/api/v1/auth/profile`,
    method: 'GET',
    signal,
  })
}

export const getGetProfileQueryKey = () => {
  return [`/api/v1/auth/profile`] as const
}

export const getGetProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProfileQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProfile>>
  > = async ({ signal }) => getProfile(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProfileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProfile>>
>
export type GetProfileQueryError = ErrorResponse

export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponse,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          Awaited<ReturnType<typeof getProfile>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          Awaited<ReturnType<typeof getProfile>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get user profile
 */

export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProfileQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Returns the session claims from the current authenticated request
 * @summary Get session claims
 */
export const getSessionClaims = async (signal?: AbortSignal) => {
  return getAxiosInstance<SessionClaimsResponse>({
    url: `/api/v1/auth/session`,
    method: 'GET',
    signal,
  })
}

export const getGetSessionClaimsQueryKey = () => {
  return [`/api/v1/auth/session`] as const
}

export const getGetSessionClaimsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSessionClaims>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetSessionClaimsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSessionClaims>>
  > = async ({ signal }) => getSessionClaims(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSessionClaims>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionClaimsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSessionClaims>>
>
export type GetSessionClaimsQueryError = ErrorResponse

export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponse,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionClaims>>,
          TError,
          Awaited<ReturnType<typeof getSessionClaims>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionClaims>>,
          TError,
          Awaited<ReturnType<typeof getSessionClaims>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get session claims
 */

export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetSessionClaimsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves a list of all users with optional filtering
 * @summary List all users
 */
export const listUsers = async (
  params?: ListUsersParams,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<UserResponse[]>({
    url: `/api/v1/users`,
    method: 'GET',
    params,
    signal,
  })
}

export const getListUsersQueryKey = (params?: ListUsersParams) => {
  return [`/api/v1/users`, ...(params ? [params] : [])] as const
}

export const getListUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorResponse,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListUsersQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsers>>> = async ({
    signal,
  }) => listUsers(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof listUsers>>
>
export type ListUsersQueryError = ErrorResponse

export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorResponse,
>(
  params: undefined | ListUsersParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorResponse,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorResponse,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List all users
 */

export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError = ErrorResponse,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListUsersQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Creates a new user in the system
 * @summary Create a new user
 */
export const createUser = async (
  createUserRequest: CreateUserRequest,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<UserResponse>({
    url: `/api/v1/users`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createUserRequest,
    signal,
  })
}

export const getCreateUserMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: CreateUserRequest },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: CreateUserRequest },
  TContext
> => {
  const mutationKey = ['createUser']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    { data: CreateUserRequest }
  > = async (props) => {
    const { data } = props ?? {}

    return createUser(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>
export type CreateUserMutationBody = CreateUserRequest
export type CreateUserMutationError = ErrorResponse

/**
 * @summary Create a new user
 */
export const useCreateUser = <TError = ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUser>>,
      TError,
      { data: CreateUserRequest },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: CreateUserRequest },
  TContext
> => {
  const mutationOptions = getCreateUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Retrieves a specific user by their UUID
 * @summary Get user by ID
 */
export const getUser = async (id: Uuid, signal?: AbortSignal) => {
  return getAxiosInstance<UserResponse>({
    url: `/api/v1/users/${id}`,
    method: 'GET',
    signal,
  })
}

export const getGetUserQueryKey = (id?: Uuid) => {
  return [`/api/v1/users/${id}`] as const
}

export const getGetUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorResponse,
>(
  id: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = async ({
    signal,
  }) => getUser(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }
}

export type GetUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUser>>
>
export type GetUserQueryError = ErrorResponse

export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorResponse,
>(
  id: Uuid,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorResponse,
>(
  id: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorResponse,
>(
  id: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get user by ID
 */

export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorResponse,
>(
  id: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetUserQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Updates an existing user
 * @summary Update user
 */
export const updateUser = async (
  id: Uuid,
  updateUserRequest: UpdateUserRequest,
) => {
  return getAxiosInstance<UserResponse>({
    url: `/api/v1/users/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateUserRequest,
  })
}

export const getUpdateUserMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { id: Uuid; data: UpdateUserRequest },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: Uuid; data: UpdateUserRequest },
  TContext
> => {
  const mutationKey = ['updateUser']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { id: Uuid; data: UpdateUserRequest }
  > = async (props) => {
    const { id, data } = props ?? {}

    return updateUser(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>
export type UpdateUserMutationBody = UpdateUserRequest
export type UpdateUserMutationError = ErrorResponse

/**
 * @summary Update user
 */
export const useUpdateUser = <TError = ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateUser>>,
      TError,
      { id: Uuid; data: UpdateUserRequest },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: Uuid; data: UpdateUserRequest },
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Deletes a user from the system
 * @summary Delete user
 */
export const deleteUser = async (id: Uuid) => {
  return getAxiosInstance<MessageResponse>({
    url: `/api/v1/users/${id}`,
    method: 'DELETE',
  })
}

export const getDeleteUserMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { id: Uuid },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { id: Uuid },
  TContext
> => {
  const mutationKey = ['deleteUser']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUser>>,
    { id: Uuid }
  > = async (props) => {
    const { id } = props ?? {}

    return deleteUser(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUser>>
>

export type DeleteUserMutationError = ErrorResponse

/**
 * @summary Delete user
 */
export const useDeleteUser = <TError = ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteUser>>,
      TError,
      { id: Uuid },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { id: Uuid },
  TContext
> => {
  const mutationOptions = getDeleteUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Activates a user (sets is_active to true)
 * @summary Activate user
 */
export const activateUser = async (id: Uuid, signal?: AbortSignal) => {
  return getAxiosInstance<MessageResponse>({
    url: `/api/v1/users/${id}/activate`,
    method: 'POST',
    signal,
  })
}

export const getActivateUserMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof activateUser>>,
    TError,
    { id: Uuid },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof activateUser>>,
  TError,
  { id: Uuid },
  TContext
> => {
  const mutationKey = ['activateUser']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof activateUser>>,
    { id: Uuid }
  > = async (props) => {
    const { id } = props ?? {}

    return activateUser(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type ActivateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof activateUser>>
>

export type ActivateUserMutationError = ErrorResponse

/**
 * @summary Activate user
 */
export const useActivateUser = <TError = ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof activateUser>>,
      TError,
      { id: Uuid },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof activateUser>>,
  TError,
  { id: Uuid },
  TContext
> => {
  const mutationOptions = getActivateUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Deactivates a user (sets is_active to false)
 * @summary Deactivate user
 */
export const deactivateUser = async (id: Uuid, signal?: AbortSignal) => {
  return getAxiosInstance<MessageResponse>({
    url: `/api/v1/users/${id}/deactivate`,
    method: 'POST',
    signal,
  })
}

export const getDeactivateUserMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deactivateUser>>,
    TError,
    { id: Uuid },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deactivateUser>>,
  TError,
  { id: Uuid },
  TContext
> => {
  const mutationKey = ['deactivateUser']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deactivateUser>>,
    { id: Uuid }
  > = async (props) => {
    const { id } = props ?? {}

    return deactivateUser(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeactivateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof deactivateUser>>
>

export type DeactivateUserMutationError = ErrorResponse

/**
 * @summary Deactivate user
 */
export const useDeactivateUser = <TError = ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deactivateUser>>,
      TError,
      { id: Uuid },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deactivateUser>>,
  TError,
  { id: Uuid },
  TContext
> => {
  const mutationOptions = getDeactivateUserMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Searches for users by name (partial match)
 * @summary Search users by name
 */
export const searchUsers = async (
  params: SearchUsersParams,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<UserResponse[]>({
    url: `/api/v1/users/search`,
    method: 'GET',
    params,
    signal,
  })
}

export const getSearchUsersQueryKey = (params?: SearchUsersParams) => {
  return [`/api/v1/users/search`, ...(params ? [params] : [])] as const
}

export const getSearchUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = ErrorResponse,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getSearchUsersQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchUsers>>
  > = async ({ signal }) => searchUsers(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchUsers>>
>
export type SearchUsersQueryError = ErrorResponse

export function useSearchUsers<
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = ErrorResponse,
>(
  params: SearchUsersParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsers>>,
          TError,
          Awaited<ReturnType<typeof searchUsers>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSearchUsers<
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = ErrorResponse,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsers>>,
          TError,
          Awaited<ReturnType<typeof searchUsers>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSearchUsers<
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = ErrorResponse,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Search users by name
 */

export function useSearchUsers<
  TData = Awaited<ReturnType<typeof searchUsers>>,
  TError = ErrorResponse,
>(
  params: SearchUsersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getSearchUsersQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves all product categories with their child categories
 * @summary List all categories
 */
export const listCategories = async (signal?: AbortSignal) => {
  return getAxiosInstance<CategoryWithChildrenResponse[]>({
    url: `/api/v1/categories`,
    method: 'GET',
    signal,
  })
}

export const getListCategoriesQueryKey = () => {
  return [`/api/v1/categories`] as const
}

export const getListCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListCategoriesQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listCategories>>
  > = async ({ signal }) => listCategories(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListCategoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof listCategories>>
>
export type ListCategoriesQueryError = ErrorResponse

export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponse,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCategories>>,
          TError,
          Awaited<ReturnType<typeof listCategories>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCategories>>,
          TError,
          Awaited<ReturnType<typeof listCategories>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List all categories
 */

export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListCategoriesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Creates a new product category
 * @summary Create category
 */
export const createCategory = async (
  createCategoryRequest: CreateCategoryRequest,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<CategoryResponse>({
    url: `/api/v1/categories`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createCategoryRequest,
    signal,
  })
}

export const getCreateCategoryMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCategory>>,
    TError,
    { data: CreateCategoryRequest },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: CreateCategoryRequest },
  TContext
> => {
  const mutationKey = ['createCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCategory>>,
    { data: CreateCategoryRequest }
  > = async (props) => {
    const { data } = props ?? {}

    return createCategory(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCategory>>
>
export type CreateCategoryMutationBody = CreateCategoryRequest
export type CreateCategoryMutationError = ErrorResponse

/**
 * @summary Create category
 */
export const useCreateCategory = <TError = ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCategory>>,
      TError,
      { data: CreateCategoryRequest },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: CreateCategoryRequest },
  TContext
> => {
  const mutationOptions = getCreateCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Updates an existing product category
 * @summary Update category
 */
export const updateCategory = async (
  id: Uuid,
  updateCategoryRequest: UpdateCategoryRequest,
) => {
  return getAxiosInstance<CategoryResponse>({
    url: `/api/v1/categories/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateCategoryRequest,
  })
}

export const getUpdateCategoryMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCategory>>,
    TError,
    { id: Uuid; data: UpdateCategoryRequest },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { id: Uuid; data: UpdateCategoryRequest },
  TContext
> => {
  const mutationKey = ['updateCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCategory>>,
    { id: Uuid; data: UpdateCategoryRequest }
  > = async (props) => {
    const { id, data } = props ?? {}

    return updateCategory(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCategory>>
>
export type UpdateCategoryMutationBody = UpdateCategoryRequest
export type UpdateCategoryMutationError = ErrorResponse

/**
 * @summary Update category
 */
export const useUpdateCategory = <TError = ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateCategory>>,
      TError,
      { id: Uuid; data: UpdateCategoryRequest },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { id: Uuid; data: UpdateCategoryRequest },
  TContext
> => {
  const mutationOptions = getUpdateCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Deletes a product category
 * @summary Delete category
 */
export const deleteCategory = async (id: Uuid) => {
  return getAxiosInstance<MessageResponse>({
    url: `/api/v1/categories/${id}`,
    method: 'DELETE',
  })
}

export const getDeleteCategoryMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCategory>>,
    TError,
    { id: Uuid },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteCategory>>,
  TError,
  { id: Uuid },
  TContext
> => {
  const mutationKey = ['deleteCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCategory>>,
    { id: Uuid }
  > = async (props) => {
    const { id } = props ?? {}

    return deleteCategory(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCategory>>
>

export type DeleteCategoryMutationError = ErrorResponse

/**
 * @summary Delete category
 */
export const useDeleteCategory = <TError = ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteCategory>>,
      TError,
      { id: Uuid },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteCategory>>,
  TError,
  { id: Uuid },
  TContext
> => {
  const mutationOptions = getDeleteCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Retrieves all products in the catalog
 * @summary List all products
 */
export const listProducts = async (signal?: AbortSignal) => {
  return getAxiosInstance<ProductResponse[]>({
    url: `/api/v1/products`,
    method: 'GET',
    signal,
  })
}

export const getListProductsQueryKey = () => {
  return [`/api/v1/products`] as const
}

export const getListProductsQueryOptions = <
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponse,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListProductsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listProducts>>
  > = async ({ signal }) => listProducts(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListProductsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listProducts>>
>
export type ListProductsQueryError = ErrorResponse

export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponse,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProducts>>,
          TError,
          Awaited<ReturnType<typeof listProducts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProducts>>,
          TError,
          Awaited<ReturnType<typeof listProducts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List all products
 */

export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponse,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListProductsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Creates a new product in the catalog
 * @summary Create product
 */
export const createProduct = async (
  createProductRequest: CreateProductRequest,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponse>({
    url: `/api/v1/products`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createProductRequest,
    signal,
  })
}

export const getCreateProductMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProduct>>,
    TError,
    { data: CreateProductRequest },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { data: CreateProductRequest },
  TContext
> => {
  const mutationKey = ['createProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProduct>>,
    { data: CreateProductRequest }
  > = async (props) => {
    const { data } = props ?? {}

    return createProduct(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProduct>>
>
export type CreateProductMutationBody = CreateProductRequest
export type CreateProductMutationError = ErrorResponse

/**
 * @summary Create product
 */
export const useCreateProduct = <TError = ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProduct>>,
      TError,
      { data: CreateProductRequest },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { data: CreateProductRequest },
  TContext
> => {
  const mutationOptions = getCreateProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Retrieves a specific product by UUID
 * @summary Get product by ID
 */
export const getProduct = async (id: Uuid, signal?: AbortSignal) => {
  return getAxiosInstance<ProductResponse>({
    url: `/api/v1/products/${id}`,
    method: 'GET',
    signal,
  })
}

export const getGetProductQueryKey = (id?: Uuid) => {
  return [`/api/v1/products/${id}`] as const
}

export const getGetProductQueryOptions = <
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponse,
>(
  id: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProductQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProduct>>
  > = async ({ signal }) => getProduct(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProduct>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProduct>>
>
export type GetProductQueryError = ErrorResponse

export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponse,
>(
  id: Uuid,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponse,
>(
  id: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponse,
>(
  id: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get product by ID
 */

export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponse,
>(
  id: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProductQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Updates an existing product
 * @summary Update product
 */
export const updateProduct = async (
  id: Uuid,
  updateProductRequest: UpdateProductRequest,
) => {
  return getAxiosInstance<ProductResponse>({
    url: `/api/v1/products/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateProductRequest,
  })
}

export const getUpdateProductMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProduct>>,
    TError,
    { id: Uuid; data: UpdateProductRequest },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { id: Uuid; data: UpdateProductRequest },
  TContext
> => {
  const mutationKey = ['updateProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProduct>>,
    { id: Uuid; data: UpdateProductRequest }
  > = async (props) => {
    const { id, data } = props ?? {}

    return updateProduct(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProduct>>
>
export type UpdateProductMutationBody = UpdateProductRequest
export type UpdateProductMutationError = ErrorResponse

/**
 * @summary Update product
 */
export const useUpdateProduct = <TError = ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProduct>>,
      TError,
      { id: Uuid; data: UpdateProductRequest },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { id: Uuid; data: UpdateProductRequest },
  TContext
> => {
  const mutationOptions = getUpdateProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Deletes a product from the catalog
 * @summary Delete product
 */
export const deleteProduct = async (id: Uuid) => {
  return getAxiosInstance<MessageResponse>({
    url: `/api/v1/products/${id}`,
    method: 'DELETE',
  })
}

export const getDeleteProductMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProduct>>,
    TError,
    { id: Uuid },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { id: Uuid },
  TContext
> => {
  const mutationKey = ['deleteProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProduct>>,
    { id: Uuid }
  > = async (props) => {
    const { id } = props ?? {}

    return deleteProduct(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProduct>>
>

export type DeleteProductMutationError = ErrorResponse

/**
 * @summary Delete product
 */
export const useDeleteProduct = <TError = ErrorResponse, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProduct>>,
      TError,
      { id: Uuid },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { id: Uuid },
  TContext
> => {
  const mutationOptions = getDeleteProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Retrieves all products in a specific category
 * @summary Get products by category
 */
export const getProductsByCategory = async (
  categoryId: Uuid,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponse[]>({
    url: `/api/v1/products/category/${categoryId}`,
    method: 'GET',
    signal,
  })
}

export const getGetProductsByCategoryQueryKey = (categoryId?: Uuid) => {
  return [`/api/v1/products/category/${categoryId}`] as const
}

export const getGetProductsByCategoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponse,
>(
  categoryId: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetProductsByCategoryQueryKey(categoryId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProductsByCategory>>
  > = async ({ signal }) => getProductsByCategory(categoryId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!categoryId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductsByCategory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductsByCategoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProductsByCategory>>
>
export type GetProductsByCategoryQueryError = ErrorResponse

export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponse,
>(
  categoryId: Uuid,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponse,
>(
  categoryId: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponse,
>(
  categoryId: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get products by category
 */

export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponse,
>(
  categoryId: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProductsByCategoryQueryOptions(categoryId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves all products in a category and its child categories
 * @summary Get products by category tree
 */
export const getProductsByCategoryTree = async (
  categoryId: Uuid,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponse[]>({
    url: `/api/v1/products/category/${categoryId}/tree`,
    method: 'GET',
    signal,
  })
}

export const getGetProductsByCategoryTreeQueryKey = (categoryId?: Uuid) => {
  return [`/api/v1/products/category/${categoryId}/tree`] as const
}

export const getGetProductsByCategoryTreeQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponse,
>(
  categoryId: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetProductsByCategoryTreeQueryKey(categoryId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProductsByCategoryTree>>
  > = async ({ signal }) => getProductsByCategoryTree(categoryId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!categoryId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductsByCategoryTree>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductsByCategoryTreeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProductsByCategoryTree>>
>
export type GetProductsByCategoryTreeQueryError = ErrorResponse

export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponse,
>(
  categoryId: Uuid,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategoryTree>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategoryTree>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponse,
>(
  categoryId: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategoryTree>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategoryTree>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponse,
>(
  categoryId: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get products by category tree
 */

export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponse,
>(
  categoryId: Uuid,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProductsByCategoryTreeQueryOptions(
    categoryId,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}
