/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * LibreStock Inventory API
 * REST API for LibreStock Inventory Management System
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import { getAxiosInstance } from './axios-client'
export interface ProfileResponseDto {
  [key: string]: unknown
}

export interface ErrorResponseDto {
  error: string
}

export interface SessionClaimsResponseDto {
  user_id: string
  session_id: string
  expires_at: number
  issued_at: number
}

/**
 * Parent category ID
 * @nullable
 */
export type CategoryWithChildrenResponseDtoParentId = {
  [key: string]: unknown
} | null

/**
 * Category description
 * @nullable
 */
export type CategoryWithChildrenResponseDtoDescription = {
  [key: string]: unknown
} | null

export interface CategoryWithChildrenResponseDto {
  /** Creation timestamp */
  created_at: string
  /** Last update timestamp */
  updated_at: string
  /** Unique identifier */
  id: string
  /** Category name */
  name: string
  /**
   * Parent category ID
   * @nullable
   */
  parent_id: CategoryWithChildrenResponseDtoParentId
  /**
   * Category description
   * @nullable
   */
  description: CategoryWithChildrenResponseDtoDescription
  /** Child categories */
  children: CategoryWithChildrenResponseDto[]
}

export interface CreateCategoryDto {
  /**
   * Category name
   * @minLength 1
   * @maxLength 100
   */
  name: string
  /**
   * Parent category ID
   * @nullable
   */
  parent_id?: string | null
  /**
   * Category description
   * @maxLength 500
   * @nullable
   */
  description?: string | null
}

/**
 * Parent category ID
 * @nullable
 */
export type CategoryResponseDtoParentId = { [key: string]: unknown } | null

/**
 * Category description
 * @nullable
 */
export type CategoryResponseDtoDescription = { [key: string]: unknown } | null

export interface CategoryResponseDto {
  /** Creation timestamp */
  created_at: string
  /** Last update timestamp */
  updated_at: string
  /** Unique identifier */
  id: string
  /** Category name */
  name: string
  /**
   * Parent category ID
   * @nullable
   */
  parent_id: CategoryResponseDtoParentId
  /**
   * Category description
   * @nullable
   */
  description: CategoryResponseDtoDescription
}

export interface UpdateCategoryDto {
  /**
   * Category name
   * @minLength 1
   * @maxLength 100
   */
  name?: string
  /**
   * Parent category ID
   * @nullable
   */
  parent_id?: string | null
  /**
   * Category description
   * @maxLength 500
   * @nullable
   */
  description?: string | null
}

export interface MessageResponseDto {
  message: string
}

/**
 * Parent category ID
 * @nullable
 */
export type CategorySummaryDtoParentId = { [key: string]: unknown } | null

export interface CategorySummaryDto {
  /** Category ID */
  id: string
  /** Category name */
  name: string
  /**
   * Parent category ID
   * @nullable
   */
  parent_id: CategorySummaryDtoParentId
}

export interface SupplierSummaryDto {
  /** Supplier ID */
  id: string
  /** Supplier name */
  name: string
}

/**
 * HTTP method for this link
 */
export type HateoasLinkMethod =
  (typeof HateoasLinkMethod)[keyof typeof HateoasLinkMethod]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HateoasLinkMethod = {
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  PATCH: 'PATCH',
  DELETE: 'DELETE',
} as const

export interface HateoasLink {
  /** The URL of the linked resource */
  href: string
  /** HTTP method for this link */
  method?: HateoasLinkMethod
}

export interface ProductLinksDto {
  /** Link to this product */
  self: HateoasLink
  /** Link to update this product */
  update: HateoasLink
  /** Link to delete this product */
  delete: HateoasLink
  /** Link to the product category */
  category: HateoasLink
}

/**
 * Deletion timestamp (for soft-deleted records)
 * @nullable
 */
export type ProductResponseDtoDeletedAt = { [key: string]: unknown } | null

/**
 * User ID who created the record
 * @nullable
 */
export type ProductResponseDtoCreatedBy = { [key: string]: unknown } | null

/**
 * User ID who last updated the record
 * @nullable
 */
export type ProductResponseDtoUpdatedBy = { [key: string]: unknown } | null

/**
 * User ID who deleted the record
 * @nullable
 */
export type ProductResponseDtoDeletedBy = { [key: string]: unknown } | null

/**
 * Product description
 * @nullable
 */
export type ProductResponseDtoDescription = { [key: string]: unknown } | null

/**
 * Nested category information
 * @nullable
 */
export type ProductResponseDtoCategory = CategorySummaryDto | null

/**
 * Brand ID
 * @nullable
 */
export type ProductResponseDtoBrandId = { [key: string]: unknown } | null

/**
 * Volume in milliliters
 * @nullable
 */
export type ProductResponseDtoVolumeMl = { [key: string]: unknown } | null

/**
 * Weight in kilograms
 * @nullable
 */
export type ProductResponseDtoWeightKg = { [key: string]: unknown } | null

/**
 * Dimensions in cm (format: LxWxH)
 * @nullable
 */
export type ProductResponseDtoDimensionsCm = { [key: string]: unknown } | null

/**
 * Standard cost
 * @nullable
 */
export type ProductResponseDtoStandardCost = { [key: string]: unknown } | null

/**
 * Standard price
 * @nullable
 */
export type ProductResponseDtoStandardPrice = { [key: string]: unknown } | null

/**
 * Markup percentage
 * @nullable
 */
export type ProductResponseDtoMarkupPercentage = {
  [key: string]: unknown
} | null

/**
 * Primary supplier ID
 * @nullable
 */
export type ProductResponseDtoPrimarySupplierId = {
  [key: string]: unknown
} | null

/**
 * Nested supplier information
 * @nullable
 */
export type ProductResponseDtoPrimarySupplier = SupplierSummaryDto | null

/**
 * Supplier SKU
 * @nullable
 */
export type ProductResponseDtoSupplierSku = { [key: string]: unknown } | null

/**
 * Product barcode
 * @nullable
 */
export type ProductResponseDtoBarcode = { [key: string]: unknown } | null

/**
 * Unit of measure
 * @nullable
 */
export type ProductResponseDtoUnit = { [key: string]: unknown } | null

/**
 * Additional notes
 * @nullable
 */
export type ProductResponseDtoNotes = { [key: string]: unknown } | null

export interface ProductResponseDto {
  /** Creation timestamp */
  created_at: string
  /** Last update timestamp */
  updated_at: string
  /**
   * Deletion timestamp (for soft-deleted records)
   * @nullable
   */
  deleted_at?: ProductResponseDtoDeletedAt
  /**
   * User ID who created the record
   * @nullable
   */
  created_by?: ProductResponseDtoCreatedBy
  /**
   * User ID who last updated the record
   * @nullable
   */
  updated_by?: ProductResponseDtoUpdatedBy
  /**
   * User ID who deleted the record
   * @nullable
   */
  deleted_by?: ProductResponseDtoDeletedBy
  /** Unique identifier */
  id: string
  /** Product SKU */
  sku: string
  /** Product name */
  name: string
  /**
   * Product description
   * @nullable
   */
  description: ProductResponseDtoDescription
  /** Category ID */
  category_id: string
  /**
   * Nested category information
   * @nullable
   */
  category?: ProductResponseDtoCategory
  /**
   * Brand ID
   * @nullable
   */
  brand_id: ProductResponseDtoBrandId
  /**
   * Volume in milliliters
   * @nullable
   */
  volume_ml: ProductResponseDtoVolumeMl
  /**
   * Weight in kilograms
   * @nullable
   */
  weight_kg: ProductResponseDtoWeightKg
  /**
   * Dimensions in cm (format: LxWxH)
   * @nullable
   */
  dimensions_cm: ProductResponseDtoDimensionsCm
  /**
   * Standard cost
   * @nullable
   */
  standard_cost: ProductResponseDtoStandardCost
  /**
   * Standard price
   * @nullable
   */
  standard_price: ProductResponseDtoStandardPrice
  /**
   * Markup percentage
   * @nullable
   */
  markup_percentage: ProductResponseDtoMarkupPercentage
  /** Reorder point threshold */
  reorder_point: number
  /**
   * Primary supplier ID
   * @nullable
   */
  primary_supplier_id: ProductResponseDtoPrimarySupplierId
  /**
   * Nested supplier information
   * @nullable
   */
  primary_supplier?: ProductResponseDtoPrimarySupplier
  /**
   * Supplier SKU
   * @nullable
   */
  supplier_sku: ProductResponseDtoSupplierSku
  /**
   * Product barcode
   * @nullable
   */
  barcode: ProductResponseDtoBarcode
  /**
   * Unit of measure
   * @nullable
   */
  unit: ProductResponseDtoUnit
  /** Whether the product is active */
  is_active: boolean
  /** Whether the product is perishable */
  is_perishable: boolean
  /**
   * Additional notes
   * @nullable
   */
  notes: ProductResponseDtoNotes
  /** HATEOAS links */
  _links?: ProductLinksDto
}

export interface PaginationMeta {
  /** Current page number */
  page: number
  /** Number of items per page */
  limit: number
  /** Total number of items */
  total: number
  /** Total number of pages */
  total_pages: number
  /** Whether there is a next page */
  has_next: boolean
  /** Whether there is a previous page */
  has_previous: boolean
}

export interface PaginatedProductsResponseDto {
  /** List of products */
  data: ProductResponseDto[]
  /** Pagination metadata */
  meta: PaginationMeta
}

/**
 * Product description
 * @maxLength 1000
 * @nullable
 */
export type CreateProductDtoDescription = { [key: string]: unknown } | null

/**
 * Brand ID
 * @nullable
 */
export type CreateProductDtoBrandId = { [key: string]: unknown } | null

/**
 * Volume in milliliters
 * @minimum 1
 * @nullable
 */
export type CreateProductDtoVolumeMl = { [key: string]: unknown } | null

/**
 * Weight in kilograms
 * @minimum 0
 * @nullable
 */
export type CreateProductDtoWeightKg = { [key: string]: unknown } | null

/**
 * Dimensions in cm (format: LxWxH, e.g., 10x20x5)
 * @maxLength 50
 * @nullable
 */
export type CreateProductDtoDimensionsCm = { [key: string]: unknown } | null

/**
 * Standard cost
 * @minimum 0
 * @nullable
 */
export type CreateProductDtoStandardCost = { [key: string]: unknown } | null

/**
 * Standard price (must be >= standard_cost)
 * @minimum 0
 * @nullable
 */
export type CreateProductDtoStandardPrice = { [key: string]: unknown } | null

/**
 * Markup percentage
 * @minimum 0
 * @maximum 1000
 * @nullable
 */
export type CreateProductDtoMarkupPercentage = { [key: string]: unknown } | null

/**
 * Primary supplier ID
 * @nullable
 */
export type CreateProductDtoPrimarySupplierId = {
  [key: string]: unknown
} | null

/**
 * Supplier SKU
 * @maxLength 50
 * @nullable
 */
export type CreateProductDtoSupplierSku = { [key: string]: unknown } | null

/**
 * Product barcode
 * @maxLength 100
 * @nullable
 */
export type CreateProductDtoBarcode = { [key: string]: unknown } | null

/**
 * Unit of measure
 * @maxLength 50
 * @nullable
 */
export type CreateProductDtoUnit = { [key: string]: unknown } | null

/**
 * Additional notes
 * @maxLength 500
 * @nullable
 */
export type CreateProductDtoNotes = { [key: string]: unknown } | null

export interface CreateProductDto {
  /**
   * Product SKU
   * @minLength 1
   * @maxLength 50
   */
  sku: string
  /**
   * Product name
   * @minLength 1
   * @maxLength 200
   */
  name: string
  /**
   * Product description
   * @maxLength 1000
   * @nullable
   */
  description?: CreateProductDtoDescription
  /** Category ID */
  category_id: string
  /**
   * Brand ID
   * @nullable
   */
  brand_id?: CreateProductDtoBrandId
  /**
   * Volume in milliliters
   * @minimum 1
   * @nullable
   */
  volume_ml?: CreateProductDtoVolumeMl
  /**
   * Weight in kilograms
   * @minimum 0
   * @nullable
   */
  weight_kg?: CreateProductDtoWeightKg
  /**
   * Dimensions in cm (format: LxWxH, e.g., 10x20x5)
   * @maxLength 50
   * @nullable
   */
  dimensions_cm?: CreateProductDtoDimensionsCm
  /**
   * Standard cost
   * @minimum 0
   * @nullable
   */
  standard_cost?: CreateProductDtoStandardCost
  /**
   * Standard price (must be >= standard_cost)
   * @minimum 0
   * @nullable
   */
  standard_price?: CreateProductDtoStandardPrice
  /**
   * Markup percentage
   * @minimum 0
   * @maximum 1000
   * @nullable
   */
  markup_percentage?: CreateProductDtoMarkupPercentage
  /**
   * Reorder point threshold
   * @minimum 0
   */
  reorder_point: number
  /**
   * Primary supplier ID
   * @nullable
   */
  primary_supplier_id?: CreateProductDtoPrimarySupplierId
  /**
   * Supplier SKU
   * @maxLength 50
   * @nullable
   */
  supplier_sku?: CreateProductDtoSupplierSku
  /**
   * Product barcode
   * @maxLength 100
   * @nullable
   */
  barcode?: CreateProductDtoBarcode
  /**
   * Unit of measure
   * @maxLength 50
   * @nullable
   */
  unit?: CreateProductDtoUnit
  /** Whether the product is active */
  is_active: boolean
  /** Whether the product is perishable */
  is_perishable: boolean
  /**
   * Additional notes
   * @maxLength 500
   * @nullable
   */
  notes?: CreateProductDtoNotes
}

export interface BulkCreateProductsDto {
  /**
   * Array of products to create
   * @minItems 1
   * @maxItems 100
   */
  products: CreateProductDto[]
}

export type BulkOperationResultDtoFailuresItem = {
  id?: string
  error?: string
}

export interface BulkOperationResultDto {
  /** Number of successfully processed items */
  success_count: number
  /** Number of failed items */
  failure_count: number
  /** IDs that were successfully processed */
  succeeded: string[]
  /** Details of failed operations */
  failures: BulkOperationResultDtoFailuresItem[]
}

/**
 * Product description
 * @maxLength 1000
 * @nullable
 */
export type UpdateProductDtoDescription = { [key: string]: unknown } | null

/**
 * Brand ID
 * @nullable
 */
export type UpdateProductDtoBrandId = { [key: string]: unknown } | null

/**
 * Volume in milliliters
 * @minimum 1
 * @nullable
 */
export type UpdateProductDtoVolumeMl = { [key: string]: unknown } | null

/**
 * Weight in kilograms
 * @minimum 0
 * @nullable
 */
export type UpdateProductDtoWeightKg = { [key: string]: unknown } | null

/**
 * Dimensions in cm (format: LxWxH, e.g., 10x20x5)
 * @maxLength 50
 * @nullable
 */
export type UpdateProductDtoDimensionsCm = { [key: string]: unknown } | null

/**
 * Standard cost
 * @minimum 0
 * @nullable
 */
export type UpdateProductDtoStandardCost = { [key: string]: unknown } | null

/**
 * Standard price (must be >= standard_cost)
 * @minimum 0
 * @nullable
 */
export type UpdateProductDtoStandardPrice = { [key: string]: unknown } | null

/**
 * Markup percentage
 * @minimum 0
 * @maximum 1000
 * @nullable
 */
export type UpdateProductDtoMarkupPercentage = { [key: string]: unknown } | null

/**
 * Primary supplier ID
 * @nullable
 */
export type UpdateProductDtoPrimarySupplierId = {
  [key: string]: unknown
} | null

/**
 * Supplier SKU
 * @maxLength 50
 * @nullable
 */
export type UpdateProductDtoSupplierSku = { [key: string]: unknown } | null

/**
 * Product barcode
 * @maxLength 100
 * @nullable
 */
export type UpdateProductDtoBarcode = { [key: string]: unknown } | null

/**
 * Unit of measure
 * @maxLength 50
 * @nullable
 */
export type UpdateProductDtoUnit = { [key: string]: unknown } | null

/**
 * Additional notes
 * @maxLength 500
 * @nullable
 */
export type UpdateProductDtoNotes = { [key: string]: unknown } | null

export interface UpdateProductDto {
  /**
   * Product SKU
   * @minLength 1
   * @maxLength 50
   */
  sku?: string
  /**
   * Product name
   * @minLength 1
   * @maxLength 200
   */
  name?: string
  /**
   * Product description
   * @maxLength 1000
   * @nullable
   */
  description?: UpdateProductDtoDescription
  /**
   * Category ID
   * @nullable
   */
  category_id?: string | null
  /**
   * Brand ID
   * @nullable
   */
  brand_id?: UpdateProductDtoBrandId
  /**
   * Volume in milliliters
   * @minimum 1
   * @nullable
   */
  volume_ml?: UpdateProductDtoVolumeMl
  /**
   * Weight in kilograms
   * @minimum 0
   * @nullable
   */
  weight_kg?: UpdateProductDtoWeightKg
  /**
   * Dimensions in cm (format: LxWxH, e.g., 10x20x5)
   * @maxLength 50
   * @nullable
   */
  dimensions_cm?: UpdateProductDtoDimensionsCm
  /**
   * Standard cost
   * @minimum 0
   * @nullable
   */
  standard_cost?: UpdateProductDtoStandardCost
  /**
   * Standard price (must be >= standard_cost)
   * @minimum 0
   * @nullable
   */
  standard_price?: UpdateProductDtoStandardPrice
  /**
   * Markup percentage
   * @minimum 0
   * @maximum 1000
   * @nullable
   */
  markup_percentage?: UpdateProductDtoMarkupPercentage
  /**
   * Reorder point threshold
   * @minimum 0
   * @nullable
   */
  reorder_point?: number | null
  /**
   * Primary supplier ID
   * @nullable
   */
  primary_supplier_id?: UpdateProductDtoPrimarySupplierId
  /**
   * Supplier SKU
   * @maxLength 50
   * @nullable
   */
  supplier_sku?: UpdateProductDtoSupplierSku
  /**
   * Product barcode
   * @maxLength 100
   * @nullable
   */
  barcode?: UpdateProductDtoBarcode
  /**
   * Unit of measure
   * @maxLength 50
   * @nullable
   */
  unit?: UpdateProductDtoUnit
  /**
   * Whether the product is active
   * @nullable
   */
  is_active?: boolean | null
  /**
   * Whether the product is perishable
   * @nullable
   */
  is_perishable?: boolean | null
  /**
   * Additional notes
   * @maxLength 500
   * @nullable
   */
  notes?: UpdateProductDtoNotes
}

export interface BulkUpdateStatusDto {
  /**
   * Array of product IDs to update
   * @minItems 1
   * @maxItems 100
   */
  ids: string[]
  /** New active status */
  is_active: boolean
}

export interface BulkDeleteDto {
  /**
   * Array of product IDs to delete
   * @minItems 1
   * @maxItems 100
   */
  ids: string[]
  /** Permanently delete (hard delete) instead of soft delete */
  permanent?: boolean
}

export interface BulkRestoreDto {
  /**
   * Array of product IDs to restore
   * @minItems 1
   * @maxItems 100
   */
  ids: string[]
}

/**
 * Location type
 */
export type LocationResponseDtoType =
  (typeof LocationResponseDtoType)[keyof typeof LocationResponseDtoType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LocationResponseDtoType = {
  WAREHOUSE: 'WAREHOUSE',
  SUPPLIER: 'SUPPLIER',
  IN_TRANSIT: 'IN_TRANSIT',
  CLIENT: 'CLIENT',
} as const

export interface LocationResponseDto {
  /** Creation timestamp */
  created_at: string
  /** Last update timestamp */
  updated_at: string
  /** Unique identifier */
  id: string
  /** Location name */
  name: string
  /** Location type */
  type: LocationResponseDtoType
  /** Physical address */
  address: string
  /** Contact person name */
  contact_person: string
  /** Phone number */
  phone: string
  /** Whether the location is active */
  is_active: boolean
}

export interface PaginatedLocationsResponseDto {
  /** List of locations */
  data: LocationResponseDto[]
  /** Pagination metadata */
  meta: PaginationMeta
}

/**
 * Location type
 */
export type CreateLocationDtoType =
  (typeof CreateLocationDtoType)[keyof typeof CreateLocationDtoType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateLocationDtoType = {
  WAREHOUSE: 'WAREHOUSE',
  SUPPLIER: 'SUPPLIER',
  IN_TRANSIT: 'IN_TRANSIT',
  CLIENT: 'CLIENT',
} as const

export interface CreateLocationDto {
  /**
   * Location name
   * @minLength 1
   * @maxLength 200
   */
  name: string
  /** Location type */
  type: CreateLocationDtoType
  /** Physical address */
  address?: string
  /**
   * Contact person name
   * @maxLength 200
   */
  contact_person?: string
  /**
   * Phone number
   * @maxLength 50
   */
  phone?: string
  /** Whether the location is active */
  is_active?: boolean
}

/**
 * Location type
 */
export type UpdateLocationDtoType =
  (typeof UpdateLocationDtoType)[keyof typeof UpdateLocationDtoType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateLocationDtoType = {
  WAREHOUSE: 'WAREHOUSE',
  SUPPLIER: 'SUPPLIER',
  IN_TRANSIT: 'IN_TRANSIT',
  CLIENT: 'CLIENT',
} as const

export interface UpdateLocationDto {
  /**
   * Location name
   * @minLength 1
   * @maxLength 200
   */
  name?: string
  /** Location type */
  type?: UpdateLocationDtoType
  /** Physical address */
  address?: string
  /**
   * Contact person name
   * @maxLength 200
   */
  contact_person?: string
  /**
   * Phone number
   * @maxLength 50
   */
  phone?: string
  /** Whether the location is active */
  is_active?: boolean
}

export interface CreateAreaDto {
  /** Location ID */
  location_id: string
  /** Parent area ID (for nested areas) */
  parent_id?: string
  /** Area name */
  name: string
  /** Area code (short identifier) */
  code?: string
  /** Area description */
  description?: string
  /** Whether the area is active */
  is_active?: boolean
}

/**
 * Parent area ID
 * @nullable
 */
export type AreaResponseDtoParentId = { [key: string]: unknown } | null

export interface AreaResponseDto {
  /** Creation timestamp */
  created_at: string
  /** Last update timestamp */
  updated_at: string
  /** Unique identifier */
  id: string
  /** Location ID */
  location_id: string
  /**
   * Parent area ID
   * @nullable
   */
  parent_id: AreaResponseDtoParentId
  /** Area name */
  name: string
  /** Area code */
  code: string
  /** Area description */
  description: string
  /** Whether the area is active */
  is_active: boolean
  /** Child areas */
  children?: AreaResponseDto[]
}

/**
 * Parent area ID (for nested areas)
 */
export type UpdateAreaDtoParentId = { [key: string]: unknown }

export interface UpdateAreaDto {
  /** Parent area ID (for nested areas) */
  parent_id?: UpdateAreaDtoParentId
  /** Area name */
  name?: string
  /** Area code (short identifier) */
  code?: string
  /** Area description */
  description?: string
  /** Whether the area is active */
  is_active?: boolean
}

/**
 * Unit of measure
 * @nullable
 */
export type ProductSummaryDtoUnit = { [key: string]: unknown } | null

export interface ProductSummaryDto {
  /** Product ID */
  id: string
  /** Product SKU */
  sku: string
  /** Product name */
  name: string
  /**
   * Unit of measure
   * @nullable
   */
  unit: ProductSummaryDtoUnit
}

export interface LocationSummaryDto {
  /** Location ID */
  id: string
  /** Location name */
  name: string
  /** Location type */
  type: string
}

export interface AreaSummaryDto {
  /** Area ID */
  id: string
  /** Area name */
  name: string
  /** Area code */
  code: string
}

/**
 * Product details
 * @nullable
 */
export type InventoryResponseDtoProduct = ProductSummaryDto | null

/**
 * Location details
 * @nullable
 */
export type InventoryResponseDtoLocation = LocationSummaryDto | null

/**
 * Area ID (specific placement within location)
 * @nullable
 */
export type InventoryResponseDtoAreaId = { [key: string]: unknown } | null

/**
 * Area details
 * @nullable
 */
export type InventoryResponseDtoArea = AreaSummaryDto | null

/**
 * Expiry date
 * @nullable
 */
export type InventoryResponseDtoExpiryDate = { [key: string]: unknown } | null

/**
 * Cost per unit
 * @nullable
 */
export type InventoryResponseDtoCostPerUnit = { [key: string]: unknown } | null

/**
 * Date when received
 * @nullable
 */
export type InventoryResponseDtoReceivedDate = { [key: string]: unknown } | null

export interface InventoryResponseDto {
  /** Creation timestamp */
  created_at: string
  /** Last update timestamp */
  updated_at: string
  /** Unique identifier */
  id: string
  /** Product ID */
  product_id: string
  /**
   * Product details
   * @nullable
   */
  product: InventoryResponseDtoProduct
  /** Location ID */
  location_id: string
  /**
   * Location details
   * @nullable
   */
  location: InventoryResponseDtoLocation
  /**
   * Area ID (specific placement within location)
   * @nullable
   */
  area_id: InventoryResponseDtoAreaId
  /**
   * Area details
   * @nullable
   */
  area: InventoryResponseDtoArea
  /** Quantity in stock */
  quantity: number
  /** Batch number */
  batchNumber: string
  /**
   * Expiry date
   * @nullable
   */
  expiry_date: InventoryResponseDtoExpiryDate
  /**
   * Cost per unit
   * @nullable
   */
  cost_per_unit: InventoryResponseDtoCostPerUnit
  /**
   * Date when received
   * @nullable
   */
  received_date: InventoryResponseDtoReceivedDate
}

export interface PaginatedInventoryResponseDto {
  /** List of inventory items */
  data: InventoryResponseDto[]
  /** Pagination metadata */
  meta: PaginationMeta
}

/**
 * Area ID (optional, specific placement within location)
 * @nullable
 */
export type CreateInventoryDtoAreaId = { [key: string]: unknown } | null

export interface CreateInventoryDto {
  /** Product ID */
  product_id: string
  /** Location ID */
  location_id: string
  /**
   * Area ID (optional, specific placement within location)
   * @nullable
   */
  area_id?: CreateInventoryDtoAreaId
  /**
   * Quantity in stock
   * @minimum 0
   */
  quantity: number
  /**
   * Batch number
   * @maxLength 100
   */
  batchNumber?: string
  /**
   * Expiry date
   * @nullable
   */
  expiry_date?: string | null
  /**
   * Cost per unit
   * @nullable
   */
  cost_per_unit?: number | null
  /**
   * Date when received
   * @nullable
   */
  received_date?: string | null
}

/**
 * Area ID (optional, specific placement within location)
 * @nullable
 */
export type UpdateInventoryDtoAreaId = { [key: string]: unknown } | null

export interface UpdateInventoryDto {
  /** Location ID */
  location_id?: string
  /**
   * Area ID (optional, specific placement within location)
   * @nullable
   */
  area_id?: UpdateInventoryDtoAreaId
  /**
   * Quantity in stock
   * @minimum 0
   */
  quantity?: number
  /**
   * Batch number
   * @maxLength 100
   */
  batchNumber?: string
  /**
   * Expiry date
   * @nullable
   */
  expiry_date?: string | null
  /**
   * Cost per unit
   * @nullable
   */
  cost_per_unit?: number | null
  /**
   * Date when received
   * @nullable
   */
  received_date?: string | null
}

export interface AdjustInventoryDto {
  /** Quantity adjustment (positive to add, negative to subtract) */
  adjustment: number
}

/**
 * User ID who performed the action
 * @nullable
 */
export type AuditLogResponseDtoUserId = { [key: string]: unknown } | null

/**
 * Action performed
 */
export type AuditLogResponseDtoAction =
  (typeof AuditLogResponseDtoAction)[keyof typeof AuditLogResponseDtoAction]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuditLogResponseDtoAction = {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  RESTORE: 'RESTORE',
  ADJUST_QUANTITY: 'ADJUST_QUANTITY',
  ADD_PHOTO: 'ADD_PHOTO',
  STATUS_CHANGE: 'STATUS_CHANGE',
} as const

/**
 * Type of entity affected
 */
export type AuditLogResponseDtoEntityType =
  (typeof AuditLogResponseDtoEntityType)[keyof typeof AuditLogResponseDtoEntityType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuditLogResponseDtoEntityType = {
  PRODUCT: 'PRODUCT',
  CATEGORY: 'CATEGORY',
  SUPPLIER: 'SUPPLIER',
  ORDER: 'ORDER',
  ORDER_ITEM: 'ORDER_ITEM',
  INVENTORY: 'INVENTORY',
  LOCATION: 'LOCATION',
  STOCK_MOVEMENT: 'STOCK_MOVEMENT',
  PHOTO: 'PHOTO',
} as const

/**
 * Changes made (before/after)
 * @nullable
 */
export type AuditLogResponseDtoChanges = { [key: string]: unknown } | null

/**
 * IP address of the requester
 * @nullable
 */
export type AuditLogResponseDtoIpAddress = { [key: string]: unknown } | null

/**
 * User agent of the requester
 * @nullable
 */
export type AuditLogResponseDtoUserAgent = { [key: string]: unknown } | null

export interface AuditLogResponseDto {
  /** Unique identifier */
  id: string
  /**
   * User ID who performed the action
   * @nullable
   */
  user_id: AuditLogResponseDtoUserId
  /** Action performed */
  action: AuditLogResponseDtoAction
  /** Type of entity affected */
  entity_type: AuditLogResponseDtoEntityType
  /** ID of the affected entity */
  entity_id: string
  /**
   * Changes made (before/after)
   * @nullable
   */
  changes: AuditLogResponseDtoChanges
  /**
   * IP address of the requester
   * @nullable
   */
  ip_address: AuditLogResponseDtoIpAddress
  /**
   * User agent of the requester
   * @nullable
   */
  user_agent: AuditLogResponseDtoUserAgent
  /** Creation timestamp */
  created_at: string
}

export interface PaginationMetaDto {
  /** Current page number */
  page: number
  /** Number of items per page */
  limit: number
  /** Total number of items */
  total: number
  /** Total number of pages */
  total_pages: number
  /** Whether there is a next page */
  has_next: boolean
  /** Whether there is a previous page */
  has_previous: boolean
}

export interface PaginatedAuditLogsResponseDto {
  /** Array of audit log entries */
  data: AuditLogResponseDto[]
  /** Pagination metadata */
  meta: PaginationMetaDto
}

/**
 * @nullable
 */
export type HealthCheck200Info = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

/**
 * @nullable
 */
export type HealthCheck200Error = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

export type HealthCheck200Details = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
}

export type HealthCheck200 = {
  status?: string
  /** @nullable */
  info?: HealthCheck200Info
  /** @nullable */
  error?: HealthCheck200Error
  details?: HealthCheck200Details
}

/**
 * @nullable
 */
export type HealthCheck503Info = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

/**
 * @nullable
 */
export type HealthCheck503Error = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

export type HealthCheck503Details = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
}

export type HealthCheck503 = {
  status?: string
  /** @nullable */
  info?: HealthCheck503Info
  /** @nullable */
  error?: HealthCheck503Error
  details?: HealthCheck503Details
}

/**
 * @nullable
 */
export type Liveness200Info = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

/**
 * @nullable
 */
export type Liveness200Error = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

export type Liveness200Details = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
}

export type Liveness200 = {
  status?: string
  /** @nullable */
  info?: Liveness200Info
  /** @nullable */
  error?: Liveness200Error
  details?: Liveness200Details
}

/**
 * @nullable
 */
export type Liveness503Info = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

/**
 * @nullable
 */
export type Liveness503Error = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

export type Liveness503Details = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
}

export type Liveness503 = {
  status?: string
  /** @nullable */
  info?: Liveness503Info
  /** @nullable */
  error?: Liveness503Error
  details?: Liveness503Details
}

/**
 * @nullable
 */
export type Readiness200Info = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

/**
 * @nullable
 */
export type Readiness200Error = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

export type Readiness200Details = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
}

export type Readiness200 = {
  status?: string
  /** @nullable */
  info?: Readiness200Info
  /** @nullable */
  error?: Readiness200Error
  details?: Readiness200Details
}

/**
 * @nullable
 */
export type Readiness503Info = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

/**
 * @nullable
 */
export type Readiness503Error = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
} | null

export type Readiness503Details = {
  [key: string]: {
    status: string
    [key: string]: unknown
  }
}

export type Readiness503 = {
  status?: string
  /** @nullable */
  info?: Readiness503Info
  /** @nullable */
  error?: Readiness503Error
  details?: Readiness503Details
}

export type ListProductsParams = {
  /**
   * Page number (1-based)
   * @minimum 1
   */
  page?: number
  /**
   * Number of items per page
   * @minimum 1
   * @maximum 100
   */
  limit?: number
  /**
   * Search term for name or SKU
   */
  search?: string
  /**
   * Filter by category ID
   */
  category_id?: string
  /**
   * Filter by brand ID
   */
  brand_id?: string
  /**
   * Filter by primary supplier ID
   */
  primary_supplier_id?: string
  /**
   * Filter by active status
   */
  is_active?: boolean
  /**
   * Filter by perishable status
   */
  is_perishable?: boolean
  /**
   * Minimum price filter
   * @minimum 0
   */
  min_price?: number
  /**
   * Maximum price filter
   * @minimum 0
   */
  max_price?: number
  /**
   * Include soft-deleted products
   */
  include_deleted?: boolean
  /**
   * Field to sort by
   */
  sort_by?: ListProductsSortBy
  /**
   * Sort order
   */
  sort_order?: ListProductsSortOrder
}

export type ListProductsSortBy =
  (typeof ListProductsSortBy)[keyof typeof ListProductsSortBy]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListProductsSortBy = {
  name: 'name',
  sku: 'sku',
  created_at: 'created_at',
  updated_at: 'updated_at',
  standard_price: 'standard_price',
  standard_cost: 'standard_cost',
  reorder_point: 'reorder_point',
} as const

export type ListProductsSortOrder =
  (typeof ListProductsSortOrder)[keyof typeof ListProductsSortOrder]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListProductsSortOrder = {
  ASC: 'ASC',
  DESC: 'DESC',
} as const

export type GetProductParams = {
  /**
   * Include soft-deleted products
   */
  include_deleted?: boolean
}

export type DeleteProductParams = {
  /**
   * Permanently delete instead of soft delete
   */
  permanent?: boolean
}

export type ListLocationsParams = {
  /**
   * Page number (1-based)
   * @minimum 1
   */
  page?: number
  /**
   * Number of items per page
   * @minimum 1
   * @maximum 100
   */
  limit?: number
  /**
   * Search term for name
   */
  search?: string
  /**
   * Filter by location type
   */
  type?: ListLocationsType
  /**
   * Filter by active status
   */
  is_active?: boolean
  /**
   * Field to sort by
   */
  sort_by?: ListLocationsSortBy
  /**
   * Sort order
   */
  sort_order?: ListLocationsSortOrder
}

export type ListLocationsType =
  (typeof ListLocationsType)[keyof typeof ListLocationsType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListLocationsType = {
  WAREHOUSE: 'WAREHOUSE',
  SUPPLIER: 'SUPPLIER',
  IN_TRANSIT: 'IN_TRANSIT',
  CLIENT: 'CLIENT',
} as const

export type ListLocationsSortBy =
  (typeof ListLocationsSortBy)[keyof typeof ListLocationsSortBy]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListLocationsSortBy = {
  name: 'name',
  type: 'type',
  created_at: 'created_at',
  updated_at: 'updated_at',
} as const

export type ListLocationsSortOrder =
  (typeof ListLocationsSortOrder)[keyof typeof ListLocationsSortOrder]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListLocationsSortOrder = {
  ASC: 'ASC',
  DESC: 'DESC',
} as const

export type AreasControllerFindAllParams = {
  /**
   * Filter by location ID
   */
  location_id?: string
  /**
   * Filter by parent area ID
   */
  parent_id?: string
  /**
   * Filter root areas only (no parent)
   */
  root_only?: boolean
  /**
   * Filter by active status
   */
  is_active?: boolean
  /**
   * Include children in response (hierarchical)
   */
  include_children?: boolean
}

export type ListInventoryParams = {
  /**
   * Page number (1-based)
   * @minimum 1
   */
  page?: number
  /**
   * Number of items per page
   * @minimum 1
   * @maximum 100
   */
  limit?: number
  /**
   * Filter by product ID
   */
  product_id?: string
  /**
   * Filter by location ID
   */
  location_id?: string
  /**
   * Filter by area ID
   */
  area_id?: string
  /**
   * Search term for batch number
   */
  search?: string
  /**
   * Filter for low stock (quantity <= reorder_point)
   */
  low_stock?: boolean
  /**
   * Filter for expiring soon (expiry_date within 30 days)
   */
  expiring_soon?: boolean
  /**
   * Minimum quantity filter
   * @minimum 0
   */
  min_quantity?: number
  /**
   * Maximum quantity filter
   * @minimum 0
   */
  max_quantity?: number
  /**
   * Field to sort by
   */
  sort_by?: ListInventorySortBy
  /**
   * Sort order
   */
  sort_order?: ListInventorySortOrder
}

export type ListInventorySortBy =
  (typeof ListInventorySortBy)[keyof typeof ListInventorySortBy]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListInventorySortBy = {
  quantity: 'quantity',
  created_at: 'created_at',
  updated_at: 'updated_at',
  expiry_date: 'expiry_date',
  received_date: 'received_date',
} as const

export type ListInventorySortOrder =
  (typeof ListInventorySortOrder)[keyof typeof ListInventorySortOrder]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListInventorySortOrder = {
  ASC: 'ASC',
  DESC: 'DESC',
} as const

export type ListAuditLogsParams = {
  /**
   * Page number (1-based)
   * @minimum 1
   */
  page?: number
  /**
   * Number of items per page
   * @minimum 1
   * @maximum 100
   */
  limit?: number
  /**
   * Filter by entity type
   */
  entity_type?: ListAuditLogsEntityType
  /**
   * Filter by entity ID
   */
  entity_id?: string
  /**
   * Filter by user ID
   */
  user_id?: string
  /**
   * Filter by action
   */
  action?: ListAuditLogsAction
  /**
   * Filter from date (ISO 8601)
   */
  from_date?: string
  /**
   * Filter to date (ISO 8601)
   */
  to_date?: string
}

export type ListAuditLogsEntityType =
  (typeof ListAuditLogsEntityType)[keyof typeof ListAuditLogsEntityType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListAuditLogsEntityType = {
  PRODUCT: 'PRODUCT',
  CATEGORY: 'CATEGORY',
  SUPPLIER: 'SUPPLIER',
  ORDER: 'ORDER',
  ORDER_ITEM: 'ORDER_ITEM',
  INVENTORY: 'INVENTORY',
  LOCATION: 'LOCATION',
  STOCK_MOVEMENT: 'STOCK_MOVEMENT',
  PHOTO: 'PHOTO',
} as const

export type ListAuditLogsAction =
  (typeof ListAuditLogsAction)[keyof typeof ListAuditLogsAction]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListAuditLogsAction = {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  RESTORE: 'RESTORE',
  ADJUST_QUANTITY: 'ADJUST_QUANTITY',
  ADD_PHOTO: 'ADD_PHOTO',
  STATUS_CHANGE: 'STATUS_CHANGE',
} as const

type AwaitedInput<T> = PromiseLike<T> | T

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never

/**
 * Comprehensive health check including database and Clerk configuration
 * @summary Full health check
 */
export const healthCheck = (signal?: AbortSignal) => {
  return getAxiosInstance<HealthCheck200>({
    url: `/health-check`,
    method: 'GET',
    signal,
  })
}

export const getHealthCheckQueryKey = () => {
  return [`/health-check`] as const
}

export const getHealthCheckQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = HealthCheck503,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getHealthCheckQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({
    signal,
  }) => healthCheck(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheck>>
>
export type HealthCheckQueryError = HealthCheck503

export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = HealthCheck503,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = HealthCheck503,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = HealthCheck503,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Full health check
 */

export function useHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheck>>,
  TError = HealthCheck503,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Kubernetes liveness probe - returns 200 if application is running
 * @summary Liveness probe
 */
export const liveness = (signal?: AbortSignal) => {
  return getAxiosInstance<Liveness200>({
    url: `/health-check/live`,
    method: 'GET',
    signal,
  })
}

export const getLivenessQueryKey = () => {
  return [`/health-check/live`] as const
}

export const getLivenessQueryOptions = <
  TData = Awaited<ReturnType<typeof liveness>>,
  TError = Liveness503,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof liveness>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getLivenessQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof liveness>>> = ({
    signal,
  }) => liveness(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof liveness>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LivenessQueryResult = NonNullable<
  Awaited<ReturnType<typeof liveness>>
>
export type LivenessQueryError = Liveness503

export function useLiveness<
  TData = Awaited<ReturnType<typeof liveness>>,
  TError = Liveness503,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof liveness>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof liveness>>,
          TError,
          Awaited<ReturnType<typeof liveness>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useLiveness<
  TData = Awaited<ReturnType<typeof liveness>>,
  TError = Liveness503,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof liveness>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof liveness>>,
          TError,
          Awaited<ReturnType<typeof liveness>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useLiveness<
  TData = Awaited<ReturnType<typeof liveness>>,
  TError = Liveness503,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof liveness>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Liveness probe
 */

export function useLiveness<
  TData = Awaited<ReturnType<typeof liveness>>,
  TError = Liveness503,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof liveness>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getLivenessQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Kubernetes readiness probe - returns 200 if application is ready to serve traffic
 * @summary Readiness probe
 */
export const readiness = (signal?: AbortSignal) => {
  return getAxiosInstance<Readiness200>({
    url: `/health-check/ready`,
    method: 'GET',
    signal,
  })
}

export const getReadinessQueryKey = () => {
  return [`/health-check/ready`] as const
}

export const getReadinessQueryOptions = <
  TData = Awaited<ReturnType<typeof readiness>>,
  TError = Readiness503,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof readiness>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getReadinessQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof readiness>>> = ({
    signal,
  }) => readiness(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof readiness>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadinessQueryResult = NonNullable<
  Awaited<ReturnType<typeof readiness>>
>
export type ReadinessQueryError = Readiness503

export function useReadiness<
  TData = Awaited<ReturnType<typeof readiness>>,
  TError = Readiness503,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof readiness>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readiness>>,
          TError,
          Awaited<ReturnType<typeof readiness>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useReadiness<
  TData = Awaited<ReturnType<typeof readiness>>,
  TError = Readiness503,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof readiness>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readiness>>,
          TError,
          Awaited<ReturnType<typeof readiness>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useReadiness<
  TData = Awaited<ReturnType<typeof readiness>>,
  TError = Readiness503,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof readiness>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Readiness probe
 */

export function useReadiness<
  TData = Awaited<ReturnType<typeof readiness>>,
  TError = Readiness503,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof readiness>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getReadinessQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves the current user profile from Clerk
 * @summary Get user profile
 */
export const getProfile = (signal?: AbortSignal) => {
  return getAxiosInstance<ProfileResponseDto>({
    url: `/auth/auth/profile`,
    method: 'GET',
    signal,
  })
}

export const getGetProfileQueryKey = () => {
  return [`/auth/auth/profile`] as const
}

export const getGetProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProfileQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfile>>> = ({
    signal,
  }) => getProfile(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProfileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProfile>>
>
export type GetProfileQueryError = ErrorResponseDto

export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          Awaited<ReturnType<typeof getProfile>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          Awaited<ReturnType<typeof getProfile>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get user profile
 */

export function useGetProfile<
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProfileQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves the current session JWT claims
 * @summary Get session claims
 */
export const getSessionClaims = (signal?: AbortSignal) => {
  return getAxiosInstance<SessionClaimsResponseDto>({
    url: `/auth/auth/session-claims`,
    method: 'GET',
    signal,
  })
}

export const getGetSessionClaimsQueryKey = () => {
  return [`/auth/auth/session-claims`] as const
}

export const getGetSessionClaimsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSessionClaims>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetSessionClaimsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSessionClaims>>
  > = ({ signal }) => getSessionClaims(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSessionClaims>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionClaimsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSessionClaims>>
>
export type GetSessionClaimsQueryError = ErrorResponseDto

export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionClaims>>,
          TError,
          Awaited<ReturnType<typeof getSessionClaims>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionClaims>>,
          TError,
          Awaited<ReturnType<typeof getSessionClaims>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get session claims
 */

export function useGetSessionClaims<
  TData = Awaited<ReturnType<typeof getSessionClaims>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionClaims>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetSessionClaimsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieves all product categories with their child categories
 * @summary List all categories
 */
export const listCategories = (signal?: AbortSignal) => {
  return getAxiosInstance<CategoryWithChildrenResponseDto[]>({
    url: `/categories`,
    method: 'GET',
    signal,
  })
}

export const getListCategoriesQueryKey = () => {
  return [`/categories`] as const
}

export const getListCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListCategoriesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listCategories>>> = ({
    signal,
  }) => listCategories(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListCategoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof listCategories>>
>
export type ListCategoriesQueryError = ErrorResponseDto

export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCategories>>,
          TError,
          Awaited<ReturnType<typeof listCategories>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCategories>>,
          TError,
          Awaited<ReturnType<typeof listCategories>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List all categories
 */

export function useListCategories<
  TData = Awaited<ReturnType<typeof listCategories>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listCategories>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListCategoriesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Creates a new product category
 * @summary Create category
 */
export const createCategory = (
  createCategoryDto: CreateCategoryDto,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<CategoryResponseDto>({
    url: `/categories`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createCategoryDto,
    signal,
  })
}

export const getCreateCategoryMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCategory>>,
    TError,
    { data: CreateCategoryDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: CreateCategoryDto },
  TContext
> => {
  const mutationKey = ['createCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCategory>>,
    { data: CreateCategoryDto }
  > = (props) => {
    const { data } = props ?? {}

    return createCategory(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCategory>>
>
export type CreateCategoryMutationBody = CreateCategoryDto
export type CreateCategoryMutationError = ErrorResponseDto

/**
 * @summary Create category
 */
export const useCreateCategory = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCategory>>,
      TError,
      { data: CreateCategoryDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: CreateCategoryDto },
  TContext
> => {
  const mutationOptions = getCreateCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Updates an existing product category
 * @summary Update category
 */
export const updateCategory = (
  id: string,
  updateCategoryDto: UpdateCategoryDto,
) => {
  return getAxiosInstance<CategoryResponseDto>({
    url: `/categories/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateCategoryDto,
  })
}

export const getUpdateCategoryMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCategory>>,
    TError,
    { id: string; data: UpdateCategoryDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { id: string; data: UpdateCategoryDto },
  TContext
> => {
  const mutationKey = ['updateCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCategory>>,
    { id: string; data: UpdateCategoryDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateCategory(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCategory>>
>
export type UpdateCategoryMutationBody = UpdateCategoryDto
export type UpdateCategoryMutationError = ErrorResponseDto

/**
 * @summary Update category
 */
export const useUpdateCategory = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateCategory>>,
      TError,
      { id: string; data: UpdateCategoryDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { id: string; data: UpdateCategoryDto },
  TContext
> => {
  const mutationOptions = getUpdateCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * Deletes a product category
 * @summary Delete category
 */
export const deleteCategory = (id: string) => {
  return getAxiosInstance<MessageResponseDto>({
    url: `/categories/${id}`,
    method: 'DELETE',
  })
}

export const getDeleteCategoryMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCategory>>,
    TError,
    { id: string },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteCategory>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteCategory']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCategory>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteCategory(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCategory>>
>

export type DeleteCategoryMutationError = ErrorResponseDto

/**
 * @summary Delete category
 */
export const useDeleteCategory = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteCategory>>,
      TError,
      { id: string },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteCategory>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteCategoryMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary List products with pagination and filtering
 */
export const listProducts = (
  params?: ListProductsParams,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<PaginatedProductsResponseDto>({
    url: `/products`,
    method: 'GET',
    params,
    signal,
  })
}

export const getListProductsQueryKey = (params?: ListProductsParams) => {
  return [`/products`, ...(params ? [params] : [])] as const
}

export const getListProductsQueryOptions = <
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  params?: ListProductsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListProductsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listProducts>>> = ({
    signal,
  }) => listProducts(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListProductsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listProducts>>
>
export type ListProductsQueryError = ErrorResponseDto

export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  params: undefined | ListProductsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProducts>>,
          TError,
          Awaited<ReturnType<typeof listProducts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  params?: ListProductsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProducts>>,
          TError,
          Awaited<ReturnType<typeof listProducts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  params?: ListProductsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List products with pagination and filtering
 */

export function useListProducts<
  TData = Awaited<ReturnType<typeof listProducts>>,
  TError = ErrorResponseDto,
>(
  params?: ListProductsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listProducts>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListProductsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create product
 */
export const createProduct = (
  createProductDto: CreateProductDto,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponseDto>({
    url: `/products`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createProductDto,
    signal,
  })
}

export const getCreateProductMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProduct>>,
    TError,
    { data: CreateProductDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { data: CreateProductDto },
  TContext
> => {
  const mutationKey = ['createProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProduct>>,
    { data: CreateProductDto }
  > = (props) => {
    const { data } = props ?? {}

    return createProduct(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProduct>>
>
export type CreateProductMutationBody = CreateProductDto
export type CreateProductMutationError = ErrorResponseDto

/**
 * @summary Create product
 */
export const useCreateProduct = <TError = ErrorResponseDto, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProduct>>,
      TError,
      { data: CreateProductDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { data: CreateProductDto },
  TContext
> => {
  const mutationOptions = getCreateProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary List all products without pagination
 */
export const listAllProducts = (signal?: AbortSignal) => {
  return getAxiosInstance<ProductResponseDto[]>({
    url: `/products/all`,
    method: 'GET',
    signal,
  })
}

export const getListAllProductsQueryKey = () => {
  return [`/products/all`] as const
}

export const getListAllProductsQueryOptions = <
  TData = Awaited<ReturnType<typeof listAllProducts>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listAllProducts>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListAllProductsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listAllProducts>>> = ({
    signal,
  }) => listAllProducts(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listAllProducts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAllProductsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listAllProducts>>
>
export type ListAllProductsQueryError = ErrorResponseDto

export function useListAllProducts<
  TData = Awaited<ReturnType<typeof listAllProducts>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllProducts>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllProducts>>,
          TError,
          Awaited<ReturnType<typeof listAllProducts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAllProducts<
  TData = Awaited<ReturnType<typeof listAllProducts>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllProducts>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllProducts>>,
          TError,
          Awaited<ReturnType<typeof listAllProducts>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAllProducts<
  TData = Awaited<ReturnType<typeof listAllProducts>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllProducts>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List all products without pagination
 */

export function useListAllProducts<
  TData = Awaited<ReturnType<typeof listAllProducts>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllProducts>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListAllProductsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get product by ID
 */
export const getProduct = (
  id: string,
  params?: GetProductParams,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponseDto>({
    url: `/products/${id}`,
    method: 'GET',
    params,
    signal,
  })
}

export const getGetProductQueryKey = (
  id?: string,
  params?: GetProductParams,
) => {
  return [`/products/${id}`, ...(params ? [params] : [])] as const
}

export const getGetProductQueryOptions = <
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  params?: GetProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProductQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProduct>>> = ({
    signal,
  }) => getProduct(id, params, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProduct>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProduct>>
>
export type GetProductQueryError = ErrorResponseDto

export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  params: undefined | GetProductParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  params?: GetProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProduct>>,
          TError,
          Awaited<ReturnType<typeof getProduct>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  params?: GetProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get product by ID
 */

export function useGetProduct<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = ErrorResponseDto,
>(
  id: string,
  params?: GetProductParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProductQueryOptions(id, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update product
 */
export const updateProduct = (
  id: string,
  updateProductDto: UpdateProductDto,
) => {
  return getAxiosInstance<ProductResponseDto>({
    url: `/products/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateProductDto,
  })
}

export const getUpdateProductMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProduct>>,
    TError,
    { id: string; data: UpdateProductDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { id: string; data: UpdateProductDto },
  TContext
> => {
  const mutationKey = ['updateProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProduct>>,
    { id: string; data: UpdateProductDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateProduct(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProduct>>
>
export type UpdateProductMutationBody = UpdateProductDto
export type UpdateProductMutationError = ErrorResponseDto

/**
 * @summary Update product
 */
export const useUpdateProduct = <TError = ErrorResponseDto, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProduct>>,
      TError,
      { id: string; data: UpdateProductDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { id: string; data: UpdateProductDto },
  TContext
> => {
  const mutationOptions = getUpdateProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Delete product
 */
export const deleteProduct = (id: string, params?: DeleteProductParams) => {
  return getAxiosInstance<MessageResponseDto>({
    url: `/products/${id}`,
    method: 'DELETE',
    params,
  })
}

export const getDeleteProductMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProduct>>,
    TError,
    { id: string; params?: DeleteProductParams },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { id: string; params?: DeleteProductParams },
  TContext
> => {
  const mutationKey = ['deleteProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProduct>>,
    { id: string; params?: DeleteProductParams }
  > = (props) => {
    const { id, params } = props ?? {}

    return deleteProduct(id, params)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProduct>>
>

export type DeleteProductMutationError = ErrorResponseDto

/**
 * @summary Delete product
 */
export const useDeleteProduct = <TError = ErrorResponseDto, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProduct>>,
      TError,
      { id: string; params?: DeleteProductParams },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { id: string; params?: DeleteProductParams },
  TContext
> => {
  const mutationOptions = getDeleteProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Get products by category
 */
export const getProductsByCategory = (
  categoryId: string,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponseDto[]>({
    url: `/products/category/${categoryId}`,
    method: 'GET',
    signal,
  })
}

export const getGetProductsByCategoryQueryKey = (categoryId?: string) => {
  return [`/products/category/${categoryId}`] as const
}

export const getGetProductsByCategoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetProductsByCategoryQueryKey(categoryId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProductsByCategory>>
  > = ({ signal }) => getProductsByCategory(categoryId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!categoryId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductsByCategory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductsByCategoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProductsByCategory>>
>
export type GetProductsByCategoryQueryError = ErrorResponseDto

export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get products by category
 */

export function useGetProductsByCategory<
  TData = Awaited<ReturnType<typeof getProductsByCategory>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProductsByCategoryQueryOptions(categoryId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get products by category tree
 */
export const getProductsByCategoryTree = (
  categoryId: string,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<ProductResponseDto[]>({
    url: `/products/category/${categoryId}/tree`,
    method: 'GET',
    signal,
  })
}

export const getGetProductsByCategoryTreeQueryKey = (categoryId?: string) => {
  return [`/products/category/${categoryId}/tree`] as const
}

export const getGetProductsByCategoryTreeQueryOptions = <
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetProductsByCategoryTreeQueryKey(categoryId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProductsByCategoryTree>>
  > = ({ signal }) => getProductsByCategoryTree(categoryId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!categoryId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProductsByCategoryTree>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductsByCategoryTreeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProductsByCategoryTree>>
>
export type GetProductsByCategoryTreeQueryError = ErrorResponseDto

export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategoryTree>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategoryTree>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductsByCategoryTree>>,
          TError,
          Awaited<ReturnType<typeof getProductsByCategoryTree>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get products by category tree
 */

export function useGetProductsByCategoryTree<
  TData = Awaited<ReturnType<typeof getProductsByCategoryTree>>,
  TError = ErrorResponseDto,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProductsByCategoryTree>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetProductsByCategoryTreeQueryOptions(
    categoryId,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Bulk create products
 */
export const bulkCreateProducts = (
  bulkCreateProductsDto: BulkCreateProductsDto,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<BulkOperationResultDto>({
    url: `/products/bulk`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: bulkCreateProductsDto,
    signal,
  })
}

export const getBulkCreateProductsMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bulkCreateProducts>>,
    TError,
    { data: BulkCreateProductsDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof bulkCreateProducts>>,
  TError,
  { data: BulkCreateProductsDto },
  TContext
> => {
  const mutationKey = ['bulkCreateProducts']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkCreateProducts>>,
    { data: BulkCreateProductsDto }
  > = (props) => {
    const { data } = props ?? {}

    return bulkCreateProducts(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type BulkCreateProductsMutationResult = NonNullable<
  Awaited<ReturnType<typeof bulkCreateProducts>>
>
export type BulkCreateProductsMutationBody = BulkCreateProductsDto
export type BulkCreateProductsMutationError = ErrorResponseDto

/**
 * @summary Bulk create products
 */
export const useBulkCreateProducts = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bulkCreateProducts>>,
      TError,
      { data: BulkCreateProductsDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof bulkCreateProducts>>,
  TError,
  { data: BulkCreateProductsDto },
  TContext
> => {
  const mutationOptions = getBulkCreateProductsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Bulk delete products
 */
export const bulkDeleteProducts = (bulkDeleteDto: BulkDeleteDto) => {
  return getAxiosInstance<BulkOperationResultDto>({
    url: `/products/bulk`,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    data: bulkDeleteDto,
  })
}

export const getBulkDeleteProductsMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bulkDeleteProducts>>,
    TError,
    { data: BulkDeleteDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof bulkDeleteProducts>>,
  TError,
  { data: BulkDeleteDto },
  TContext
> => {
  const mutationKey = ['bulkDeleteProducts']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkDeleteProducts>>,
    { data: BulkDeleteDto }
  > = (props) => {
    const { data } = props ?? {}

    return bulkDeleteProducts(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type BulkDeleteProductsMutationResult = NonNullable<
  Awaited<ReturnType<typeof bulkDeleteProducts>>
>
export type BulkDeleteProductsMutationBody = BulkDeleteDto
export type BulkDeleteProductsMutationError = ErrorResponseDto

/**
 * @summary Bulk delete products
 */
export const useBulkDeleteProducts = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bulkDeleteProducts>>,
      TError,
      { data: BulkDeleteDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof bulkDeleteProducts>>,
  TError,
  { data: BulkDeleteDto },
  TContext
> => {
  const mutationOptions = getBulkDeleteProductsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Bulk update product status
 */
export const bulkUpdateProductStatus = (
  bulkUpdateStatusDto: BulkUpdateStatusDto,
) => {
  return getAxiosInstance<BulkOperationResultDto>({
    url: `/products/bulk/status`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: bulkUpdateStatusDto,
  })
}

export const getBulkUpdateProductStatusMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bulkUpdateProductStatus>>,
    TError,
    { data: BulkUpdateStatusDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof bulkUpdateProductStatus>>,
  TError,
  { data: BulkUpdateStatusDto },
  TContext
> => {
  const mutationKey = ['bulkUpdateProductStatus']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkUpdateProductStatus>>,
    { data: BulkUpdateStatusDto }
  > = (props) => {
    const { data } = props ?? {}

    return bulkUpdateProductStatus(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type BulkUpdateProductStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof bulkUpdateProductStatus>>
>
export type BulkUpdateProductStatusMutationBody = BulkUpdateStatusDto
export type BulkUpdateProductStatusMutationError = ErrorResponseDto

/**
 * @summary Bulk update product status
 */
export const useBulkUpdateProductStatus = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bulkUpdateProductStatus>>,
      TError,
      { data: BulkUpdateStatusDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof bulkUpdateProductStatus>>,
  TError,
  { data: BulkUpdateStatusDto },
  TContext
> => {
  const mutationOptions = getBulkUpdateProductStatusMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Restore deleted product
 */
export const restoreProduct = (id: string) => {
  return getAxiosInstance<ProductResponseDto>({
    url: `/products/${id}/restore`,
    method: 'PATCH',
  })
}

export const getRestoreProductMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof restoreProduct>>,
    TError,
    { id: string },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof restoreProduct>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['restoreProduct']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof restoreProduct>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return restoreProduct(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type RestoreProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof restoreProduct>>
>

export type RestoreProductMutationError = ErrorResponseDto

/**
 * @summary Restore deleted product
 */
export const useRestoreProduct = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof restoreProduct>>,
      TError,
      { id: string },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof restoreProduct>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getRestoreProductMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Bulk restore products
 */
export const bulkRestoreProducts = (bulkRestoreDto: BulkRestoreDto) => {
  return getAxiosInstance<BulkOperationResultDto>({
    url: `/products/bulk/restore`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: bulkRestoreDto,
  })
}

export const getBulkRestoreProductsMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bulkRestoreProducts>>,
    TError,
    { data: BulkRestoreDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof bulkRestoreProducts>>,
  TError,
  { data: BulkRestoreDto },
  TContext
> => {
  const mutationKey = ['bulkRestoreProducts']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkRestoreProducts>>,
    { data: BulkRestoreDto }
  > = (props) => {
    const { data } = props ?? {}

    return bulkRestoreProducts(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type BulkRestoreProductsMutationResult = NonNullable<
  Awaited<ReturnType<typeof bulkRestoreProducts>>
>
export type BulkRestoreProductsMutationBody = BulkRestoreDto
export type BulkRestoreProductsMutationError = ErrorResponseDto

/**
 * @summary Bulk restore products
 */
export const useBulkRestoreProducts = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bulkRestoreProducts>>,
      TError,
      { data: BulkRestoreDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof bulkRestoreProducts>>,
  TError,
  { data: BulkRestoreDto },
  TContext
> => {
  const mutationOptions = getBulkRestoreProductsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary List locations with pagination and filtering
 */
export const listLocations = (
  params?: ListLocationsParams,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<PaginatedLocationsResponseDto>({
    url: `/locations`,
    method: 'GET',
    params,
    signal,
  })
}

export const getListLocationsQueryKey = (params?: ListLocationsParams) => {
  return [`/locations`, ...(params ? [params] : [])] as const
}

export const getListLocationsQueryOptions = <
  TData = Awaited<ReturnType<typeof listLocations>>,
  TError = ErrorResponseDto,
>(
  params?: ListLocationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listLocations>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListLocationsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listLocations>>> = ({
    signal,
  }) => listLocations(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listLocations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListLocationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listLocations>>
>
export type ListLocationsQueryError = ErrorResponseDto

export function useListLocations<
  TData = Awaited<ReturnType<typeof listLocations>>,
  TError = ErrorResponseDto,
>(
  params: undefined | ListLocationsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listLocations>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listLocations>>,
          TError,
          Awaited<ReturnType<typeof listLocations>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListLocations<
  TData = Awaited<ReturnType<typeof listLocations>>,
  TError = ErrorResponseDto,
>(
  params?: ListLocationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listLocations>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listLocations>>,
          TError,
          Awaited<ReturnType<typeof listLocations>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListLocations<
  TData = Awaited<ReturnType<typeof listLocations>>,
  TError = ErrorResponseDto,
>(
  params?: ListLocationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listLocations>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List locations with pagination and filtering
 */

export function useListLocations<
  TData = Awaited<ReturnType<typeof listLocations>>,
  TError = ErrorResponseDto,
>(
  params?: ListLocationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listLocations>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListLocationsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create location
 */
export const createLocation = (
  createLocationDto: CreateLocationDto,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<LocationResponseDto>({
    url: `/locations`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createLocationDto,
    signal,
  })
}

export const getCreateLocationMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createLocation>>,
    TError,
    { data: CreateLocationDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createLocation>>,
  TError,
  { data: CreateLocationDto },
  TContext
> => {
  const mutationKey = ['createLocation']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createLocation>>,
    { data: CreateLocationDto }
  > = (props) => {
    const { data } = props ?? {}

    return createLocation(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateLocationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createLocation>>
>
export type CreateLocationMutationBody = CreateLocationDto
export type CreateLocationMutationError = ErrorResponseDto

/**
 * @summary Create location
 */
export const useCreateLocation = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createLocation>>,
      TError,
      { data: CreateLocationDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createLocation>>,
  TError,
  { data: CreateLocationDto },
  TContext
> => {
  const mutationOptions = getCreateLocationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary List all locations without pagination
 */
export const listAllLocations = (signal?: AbortSignal) => {
  return getAxiosInstance<LocationResponseDto[]>({
    url: `/locations/all`,
    method: 'GET',
    signal,
  })
}

export const getListAllLocationsQueryKey = () => {
  return [`/locations/all`] as const
}

export const getListAllLocationsQueryOptions = <
  TData = Awaited<ReturnType<typeof listAllLocations>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listAllLocations>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListAllLocationsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listAllLocations>>
  > = ({ signal }) => listAllLocations(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listAllLocations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAllLocationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listAllLocations>>
>
export type ListAllLocationsQueryError = ErrorResponseDto

export function useListAllLocations<
  TData = Awaited<ReturnType<typeof listAllLocations>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllLocations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllLocations>>,
          TError,
          Awaited<ReturnType<typeof listAllLocations>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAllLocations<
  TData = Awaited<ReturnType<typeof listAllLocations>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllLocations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllLocations>>,
          TError,
          Awaited<ReturnType<typeof listAllLocations>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAllLocations<
  TData = Awaited<ReturnType<typeof listAllLocations>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllLocations>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List all locations without pagination
 */

export function useListAllLocations<
  TData = Awaited<ReturnType<typeof listAllLocations>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllLocations>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListAllLocationsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get location by ID
 */
export const getLocation = (id: string, signal?: AbortSignal) => {
  return getAxiosInstance<LocationResponseDto>({
    url: `/locations/${id}`,
    method: 'GET',
    signal,
  })
}

export const getGetLocationQueryKey = (id?: string) => {
  return [`/locations/${id}`] as const
}

export const getGetLocationQueryOptions = <
  TData = Awaited<ReturnType<typeof getLocation>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLocation>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetLocationQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLocation>>> = ({
    signal,
  }) => getLocation(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getLocation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLocationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLocation>>
>
export type GetLocationQueryError = ErrorResponseDto

export function useGetLocation<
  TData = Awaited<ReturnType<typeof getLocation>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLocation>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLocation>>,
          TError,
          Awaited<ReturnType<typeof getLocation>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetLocation<
  TData = Awaited<ReturnType<typeof getLocation>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLocation>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLocation>>,
          TError,
          Awaited<ReturnType<typeof getLocation>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetLocation<
  TData = Awaited<ReturnType<typeof getLocation>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLocation>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get location by ID
 */

export function useGetLocation<
  TData = Awaited<ReturnType<typeof getLocation>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLocation>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetLocationQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update location
 */
export const updateLocation = (
  id: string,
  updateLocationDto: UpdateLocationDto,
) => {
  return getAxiosInstance<LocationResponseDto>({
    url: `/locations/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateLocationDto,
  })
}

export const getUpdateLocationMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateLocation>>,
    TError,
    { id: string; data: UpdateLocationDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateLocation>>,
  TError,
  { id: string; data: UpdateLocationDto },
  TContext
> => {
  const mutationKey = ['updateLocation']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateLocation>>,
    { id: string; data: UpdateLocationDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateLocation(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateLocationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateLocation>>
>
export type UpdateLocationMutationBody = UpdateLocationDto
export type UpdateLocationMutationError = ErrorResponseDto

/**
 * @summary Update location
 */
export const useUpdateLocation = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateLocation>>,
      TError,
      { id: string; data: UpdateLocationDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateLocation>>,
  TError,
  { id: string; data: UpdateLocationDto },
  TContext
> => {
  const mutationOptions = getUpdateLocationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Delete location
 */
export const deleteLocation = (id: string) => {
  return getAxiosInstance<MessageResponseDto>({
    url: `/locations/${id}`,
    method: 'DELETE',
  })
}

export const getDeleteLocationMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteLocation>>,
    TError,
    { id: string },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteLocation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteLocation']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteLocation>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteLocation(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteLocationMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteLocation>>
>

export type DeleteLocationMutationError = ErrorResponseDto

/**
 * @summary Delete location
 */
export const useDeleteLocation = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteLocation>>,
      TError,
      { id: string },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteLocation>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteLocationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Create a new area
 */
export const areasControllerCreate = (
  createAreaDto: CreateAreaDto,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<AreaResponseDto>({
    url: `/areas`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createAreaDto,
    signal,
  })
}

export const getAreasControllerCreateMutationOptions = <
  TError = ErrorResponseDto | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof areasControllerCreate>>,
    TError,
    { data: CreateAreaDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof areasControllerCreate>>,
  TError,
  { data: CreateAreaDto },
  TContext
> => {
  const mutationKey = ['areasControllerCreate']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof areasControllerCreate>>,
    { data: CreateAreaDto }
  > = (props) => {
    const { data } = props ?? {}

    return areasControllerCreate(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type AreasControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof areasControllerCreate>>
>
export type AreasControllerCreateMutationBody = CreateAreaDto
export type AreasControllerCreateMutationError = ErrorResponseDto | void

/**
 * @summary Create a new area
 */
export const useAreasControllerCreate = <
  TError = ErrorResponseDto | void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof areasControllerCreate>>,
      TError,
      { data: CreateAreaDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof areasControllerCreate>>,
  TError,
  { data: CreateAreaDto },
  TContext
> => {
  const mutationOptions = getAreasControllerCreateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary List areas with optional filtering
 */
export const areasControllerFindAll = (
  params?: AreasControllerFindAllParams,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<AreaResponseDto[]>({
    url: `/areas`,
    method: 'GET',
    params,
    signal,
  })
}

export const getAreasControllerFindAllQueryKey = (
  params?: AreasControllerFindAllParams,
) => {
  return [`/areas`, ...(params ? [params] : [])] as const
}

export const getAreasControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof areasControllerFindAll>>,
  TError = void,
>(
  params?: AreasControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindAll>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getAreasControllerFindAllQueryKey(params)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof areasControllerFindAll>>
  > = ({ signal }) => areasControllerFindAll(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof areasControllerFindAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AreasControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof areasControllerFindAll>>
>
export type AreasControllerFindAllQueryError = void

export function useAreasControllerFindAll<
  TData = Awaited<ReturnType<typeof areasControllerFindAll>>,
  TError = void,
>(
  params: undefined | AreasControllerFindAllParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof areasControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof areasControllerFindAll>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAreasControllerFindAll<
  TData = Awaited<ReturnType<typeof areasControllerFindAll>>,
  TError = void,
>(
  params?: AreasControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof areasControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof areasControllerFindAll>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAreasControllerFindAll<
  TData = Awaited<ReturnType<typeof areasControllerFindAll>>,
  TError = void,
>(
  params?: AreasControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindAll>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List areas with optional filtering
 */

export function useAreasControllerFindAll<
  TData = Awaited<ReturnType<typeof areasControllerFindAll>>,
  TError = void,
>(
  params?: AreasControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindAll>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getAreasControllerFindAllQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get area by ID
 */
export const areasControllerFindById = (id: string, signal?: AbortSignal) => {
  return getAxiosInstance<AreaResponseDto>({
    url: `/areas/${id}`,
    method: 'GET',
    signal,
  })
}

export const getAreasControllerFindByIdQueryKey = (id?: string) => {
  return [`/areas/${id}`] as const
}

export const getAreasControllerFindByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof areasControllerFindById>>,
  TError = void | ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindById>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getAreasControllerFindByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof areasControllerFindById>>
  > = ({ signal }) => areasControllerFindById(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof areasControllerFindById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AreasControllerFindByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof areasControllerFindById>>
>
export type AreasControllerFindByIdQueryError = void | ErrorResponseDto

export function useAreasControllerFindById<
  TData = Awaited<ReturnType<typeof areasControllerFindById>>,
  TError = void | ErrorResponseDto,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof areasControllerFindById>>,
          TError,
          Awaited<ReturnType<typeof areasControllerFindById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAreasControllerFindById<
  TData = Awaited<ReturnType<typeof areasControllerFindById>>,
  TError = void | ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof areasControllerFindById>>,
          TError,
          Awaited<ReturnType<typeof areasControllerFindById>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAreasControllerFindById<
  TData = Awaited<ReturnType<typeof areasControllerFindById>>,
  TError = void | ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindById>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get area by ID
 */

export function useAreasControllerFindById<
  TData = Awaited<ReturnType<typeof areasControllerFindById>>,
  TError = void | ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindById>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getAreasControllerFindByIdQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update an area
 */
export const areasControllerUpdate = (
  id: string,
  updateAreaDto: UpdateAreaDto,
) => {
  return getAxiosInstance<AreaResponseDto>({
    url: `/areas/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateAreaDto,
  })
}

export const getAreasControllerUpdateMutationOptions = <
  TError = ErrorResponseDto | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof areasControllerUpdate>>,
    TError,
    { id: string; data: UpdateAreaDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof areasControllerUpdate>>,
  TError,
  { id: string; data: UpdateAreaDto },
  TContext
> => {
  const mutationKey = ['areasControllerUpdate']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof areasControllerUpdate>>,
    { id: string; data: UpdateAreaDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return areasControllerUpdate(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type AreasControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof areasControllerUpdate>>
>
export type AreasControllerUpdateMutationBody = UpdateAreaDto
export type AreasControllerUpdateMutationError = ErrorResponseDto | void

/**
 * @summary Update an area
 */
export const useAreasControllerUpdate = <
  TError = ErrorResponseDto | void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof areasControllerUpdate>>,
      TError,
      { id: string; data: UpdateAreaDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof areasControllerUpdate>>,
  TError,
  { id: string; data: UpdateAreaDto },
  TContext
> => {
  const mutationOptions = getAreasControllerUpdateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Delete an area
 */
export const areasControllerDelete = (id: string) => {
  return getAxiosInstance<void>({ url: `/areas/${id}`, method: 'DELETE' })
}

export const getAreasControllerDeleteMutationOptions = <
  TError = void | ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof areasControllerDelete>>,
    TError,
    { id: string },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof areasControllerDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['areasControllerDelete']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof areasControllerDelete>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return areasControllerDelete(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type AreasControllerDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof areasControllerDelete>>
>

export type AreasControllerDeleteMutationError = void | ErrorResponseDto

/**
 * @summary Delete an area
 */
export const useAreasControllerDelete = <
  TError = void | ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof areasControllerDelete>>,
      TError,
      { id: string },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof areasControllerDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getAreasControllerDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Get area with children
 */
export const areasControllerFindByIdWithChildren = (
  id: string,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<AreaResponseDto>({
    url: `/areas/${id}/children`,
    method: 'GET',
    signal,
  })
}

export const getAreasControllerFindByIdWithChildrenQueryKey = (id?: string) => {
  return [`/areas/${id}/children`] as const
}

export const getAreasControllerFindByIdWithChildrenQueryOptions = <
  TData = Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>,
  TError = void | ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getAreasControllerFindByIdWithChildrenQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>
  > = ({ signal }) => areasControllerFindByIdWithChildren(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AreasControllerFindByIdWithChildrenQueryResult = NonNullable<
  Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>
>
export type AreasControllerFindByIdWithChildrenQueryError =
  void | ErrorResponseDto

export function useAreasControllerFindByIdWithChildren<
  TData = Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>,
  TError = void | ErrorResponseDto,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>,
          TError,
          Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAreasControllerFindByIdWithChildren<
  TData = Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>,
  TError = void | ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>,
          TError,
          Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAreasControllerFindByIdWithChildren<
  TData = Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>,
  TError = void | ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get area with children
 */

export function useAreasControllerFindByIdWithChildren<
  TData = Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>,
  TError = void | ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof areasControllerFindByIdWithChildren>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getAreasControllerFindByIdWithChildrenQueryOptions(
    id,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary List inventory items with pagination and filtering
 */
export const listInventory = (
  params?: ListInventoryParams,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<PaginatedInventoryResponseDto>({
    url: `/inventory`,
    method: 'GET',
    params,
    signal,
  })
}

export const getListInventoryQueryKey = (params?: ListInventoryParams) => {
  return [`/inventory`, ...(params ? [params] : [])] as const
}

export const getListInventoryQueryOptions = <
  TData = Awaited<ReturnType<typeof listInventory>>,
  TError = ErrorResponseDto,
>(
  params?: ListInventoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventory>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListInventoryQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listInventory>>> = ({
    signal,
  }) => listInventory(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listInventory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListInventoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof listInventory>>
>
export type ListInventoryQueryError = ErrorResponseDto

export function useListInventory<
  TData = Awaited<ReturnType<typeof listInventory>>,
  TError = ErrorResponseDto,
>(
  params: undefined | ListInventoryParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventory>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventory>>,
          TError,
          Awaited<ReturnType<typeof listInventory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListInventory<
  TData = Awaited<ReturnType<typeof listInventory>>,
  TError = ErrorResponseDto,
>(
  params?: ListInventoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventory>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInventory>>,
          TError,
          Awaited<ReturnType<typeof listInventory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListInventory<
  TData = Awaited<ReturnType<typeof listInventory>>,
  TError = ErrorResponseDto,
>(
  params?: ListInventoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventory>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List inventory items with pagination and filtering
 */

export function useListInventory<
  TData = Awaited<ReturnType<typeof listInventory>>,
  TError = ErrorResponseDto,
>(
  params?: ListInventoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listInventory>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListInventoryQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create inventory item
 */
export const createInventoryItem = (
  createInventoryDto: CreateInventoryDto,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<InventoryResponseDto>({
    url: `/inventory`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createInventoryDto,
    signal,
  })
}

export const getCreateInventoryItemMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createInventoryItem>>,
    TError,
    { data: CreateInventoryDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof createInventoryItem>>,
  TError,
  { data: CreateInventoryDto },
  TContext
> => {
  const mutationKey = ['createInventoryItem']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createInventoryItem>>,
    { data: CreateInventoryDto }
  > = (props) => {
    const { data } = props ?? {}

    return createInventoryItem(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateInventoryItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof createInventoryItem>>
>
export type CreateInventoryItemMutationBody = CreateInventoryDto
export type CreateInventoryItemMutationError = ErrorResponseDto

/**
 * @summary Create inventory item
 */
export const useCreateInventoryItem = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createInventoryItem>>,
      TError,
      { data: CreateInventoryDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createInventoryItem>>,
  TError,
  { data: CreateInventoryDto },
  TContext
> => {
  const mutationOptions = getCreateInventoryItemMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary List all inventory items without pagination
 */
export const listAllInventory = (signal?: AbortSignal) => {
  return getAxiosInstance<InventoryResponseDto[]>({
    url: `/inventory/all`,
    method: 'GET',
    signal,
  })
}

export const getListAllInventoryQueryKey = () => {
  return [`/inventory/all`] as const
}

export const getListAllInventoryQueryOptions = <
  TData = Awaited<ReturnType<typeof listAllInventory>>,
  TError = ErrorResponseDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listAllInventory>>, TError, TData>
  >
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListAllInventoryQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listAllInventory>>
  > = ({ signal }) => listAllInventory(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listAllInventory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAllInventoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof listAllInventory>>
>
export type ListAllInventoryQueryError = ErrorResponseDto

export function useListAllInventory<
  TData = Awaited<ReturnType<typeof listAllInventory>>,
  TError = ErrorResponseDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllInventory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllInventory>>,
          TError,
          Awaited<ReturnType<typeof listAllInventory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAllInventory<
  TData = Awaited<ReturnType<typeof listAllInventory>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllInventory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllInventory>>,
          TError,
          Awaited<ReturnType<typeof listAllInventory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAllInventory<
  TData = Awaited<ReturnType<typeof listAllInventory>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllInventory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List all inventory items without pagination
 */

export function useListAllInventory<
  TData = Awaited<ReturnType<typeof listAllInventory>>,
  TError = ErrorResponseDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllInventory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListAllInventoryQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get inventory by product
 */
export const getInventoryByProduct = (
  productId: string,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<InventoryResponseDto[]>({
    url: `/inventory/product/${productId}`,
    method: 'GET',
    signal,
  })
}

export const getGetInventoryByProductQueryKey = (productId?: string) => {
  return [`/inventory/product/${productId}`] as const
}

export const getGetInventoryByProductQueryOptions = <
  TData = Awaited<ReturnType<typeof getInventoryByProduct>>,
  TError = ErrorResponseDto,
>(
  productId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryByProduct>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetInventoryByProductQueryKey(productId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInventoryByProduct>>
  > = ({ signal }) => getInventoryByProduct(productId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!productId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInventoryByProduct>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInventoryByProductQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInventoryByProduct>>
>
export type GetInventoryByProductQueryError = ErrorResponseDto

export function useGetInventoryByProduct<
  TData = Awaited<ReturnType<typeof getInventoryByProduct>>,
  TError = ErrorResponseDto,
>(
  productId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryByProduct>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryByProduct>>,
          TError,
          Awaited<ReturnType<typeof getInventoryByProduct>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetInventoryByProduct<
  TData = Awaited<ReturnType<typeof getInventoryByProduct>>,
  TError = ErrorResponseDto,
>(
  productId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryByProduct>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryByProduct>>,
          TError,
          Awaited<ReturnType<typeof getInventoryByProduct>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetInventoryByProduct<
  TData = Awaited<ReturnType<typeof getInventoryByProduct>>,
  TError = ErrorResponseDto,
>(
  productId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryByProduct>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get inventory by product
 */

export function useGetInventoryByProduct<
  TData = Awaited<ReturnType<typeof getInventoryByProduct>>,
  TError = ErrorResponseDto,
>(
  productId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryByProduct>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetInventoryByProductQueryOptions(productId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get inventory by location
 */
export const getInventoryByLocation = (
  locationId: string,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<InventoryResponseDto[]>({
    url: `/inventory/location/${locationId}`,
    method: 'GET',
    signal,
  })
}

export const getGetInventoryByLocationQueryKey = (locationId?: string) => {
  return [`/inventory/location/${locationId}`] as const
}

export const getGetInventoryByLocationQueryOptions = <
  TData = Awaited<ReturnType<typeof getInventoryByLocation>>,
  TError = ErrorResponseDto,
>(
  locationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryByLocation>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetInventoryByLocationQueryKey(locationId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInventoryByLocation>>
  > = ({ signal }) => getInventoryByLocation(locationId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!locationId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInventoryByLocation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInventoryByLocationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInventoryByLocation>>
>
export type GetInventoryByLocationQueryError = ErrorResponseDto

export function useGetInventoryByLocation<
  TData = Awaited<ReturnType<typeof getInventoryByLocation>>,
  TError = ErrorResponseDto,
>(
  locationId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryByLocation>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryByLocation>>,
          TError,
          Awaited<ReturnType<typeof getInventoryByLocation>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetInventoryByLocation<
  TData = Awaited<ReturnType<typeof getInventoryByLocation>>,
  TError = ErrorResponseDto,
>(
  locationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryByLocation>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryByLocation>>,
          TError,
          Awaited<ReturnType<typeof getInventoryByLocation>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetInventoryByLocation<
  TData = Awaited<ReturnType<typeof getInventoryByLocation>>,
  TError = ErrorResponseDto,
>(
  locationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryByLocation>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get inventory by location
 */

export function useGetInventoryByLocation<
  TData = Awaited<ReturnType<typeof getInventoryByLocation>>,
  TError = ErrorResponseDto,
>(
  locationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryByLocation>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetInventoryByLocationQueryOptions(
    locationId,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get inventory item by ID
 */
export const getInventoryItem = (id: string, signal?: AbortSignal) => {
  return getAxiosInstance<InventoryResponseDto>({
    url: `/inventory/${id}`,
    method: 'GET',
    signal,
  })
}

export const getGetInventoryItemQueryKey = (id?: string) => {
  return [`/inventory/${id}`] as const
}

export const getGetInventoryItemQueryOptions = <
  TData = Awaited<ReturnType<typeof getInventoryItem>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryItem>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetInventoryItemQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInventoryItem>>
  > = ({ signal }) => getInventoryItem(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getInventoryItem>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInventoryItemQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInventoryItem>>
>
export type GetInventoryItemQueryError = ErrorResponseDto

export function useGetInventoryItem<
  TData = Awaited<ReturnType<typeof getInventoryItem>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryItem>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryItem>>,
          TError,
          Awaited<ReturnType<typeof getInventoryItem>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetInventoryItem<
  TData = Awaited<ReturnType<typeof getInventoryItem>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryItem>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInventoryItem>>,
          TError,
          Awaited<ReturnType<typeof getInventoryItem>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetInventoryItem<
  TData = Awaited<ReturnType<typeof getInventoryItem>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryItem>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get inventory item by ID
 */

export function useGetInventoryItem<
  TData = Awaited<ReturnType<typeof getInventoryItem>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInventoryItem>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetInventoryItemQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update inventory item
 */
export const updateInventoryItem = (
  id: string,
  updateInventoryDto: UpdateInventoryDto,
) => {
  return getAxiosInstance<InventoryResponseDto>({
    url: `/inventory/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateInventoryDto,
  })
}

export const getUpdateInventoryItemMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateInventoryItem>>,
    TError,
    { id: string; data: UpdateInventoryDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateInventoryItem>>,
  TError,
  { id: string; data: UpdateInventoryDto },
  TContext
> => {
  const mutationKey = ['updateInventoryItem']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateInventoryItem>>,
    { id: string; data: UpdateInventoryDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateInventoryItem(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateInventoryItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateInventoryItem>>
>
export type UpdateInventoryItemMutationBody = UpdateInventoryDto
export type UpdateInventoryItemMutationError = ErrorResponseDto

/**
 * @summary Update inventory item
 */
export const useUpdateInventoryItem = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateInventoryItem>>,
      TError,
      { id: string; data: UpdateInventoryDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateInventoryItem>>,
  TError,
  { id: string; data: UpdateInventoryDto },
  TContext
> => {
  const mutationOptions = getUpdateInventoryItemMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Delete inventory item
 */
export const deleteInventoryItem = (id: string) => {
  return getAxiosInstance<MessageResponseDto>({
    url: `/inventory/${id}`,
    method: 'DELETE',
  })
}

export const getDeleteInventoryItemMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteInventoryItem>>,
    TError,
    { id: string },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteInventoryItem>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteInventoryItem']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteInventoryItem>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return deleteInventoryItem(id)
  }

  return { mutationFn, ...mutationOptions }
}

export type DeleteInventoryItemMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteInventoryItem>>
>

export type DeleteInventoryItemMutationError = ErrorResponseDto

/**
 * @summary Delete inventory item
 */
export const useDeleteInventoryItem = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteInventoryItem>>,
      TError,
      { id: string },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteInventoryItem>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteInventoryItemMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary Adjust inventory quantity
 */
export const adjustInventoryQuantity = (
  id: string,
  adjustInventoryDto: AdjustInventoryDto,
) => {
  return getAxiosInstance<InventoryResponseDto>({
    url: `/inventory/${id}/adjust`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: adjustInventoryDto,
  })
}

export const getAdjustInventoryQuantityMutationOptions = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adjustInventoryQuantity>>,
    TError,
    { id: string; data: AdjustInventoryDto },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof adjustInventoryQuantity>>,
  TError,
  { id: string; data: AdjustInventoryDto },
  TContext
> => {
  const mutationKey = ['adjustInventoryQuantity']
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adjustInventoryQuantity>>,
    { id: string; data: AdjustInventoryDto }
  > = (props) => {
    const { id, data } = props ?? {}

    return adjustInventoryQuantity(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type AdjustInventoryQuantityMutationResult = NonNullable<
  Awaited<ReturnType<typeof adjustInventoryQuantity>>
>
export type AdjustInventoryQuantityMutationBody = AdjustInventoryDto
export type AdjustInventoryQuantityMutationError = ErrorResponseDto

/**
 * @summary Adjust inventory quantity
 */
export const useAdjustInventoryQuantity = <
  TError = ErrorResponseDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof adjustInventoryQuantity>>,
      TError,
      { id: string; data: AdjustInventoryDto },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof adjustInventoryQuantity>>,
  TError,
  { id: string; data: AdjustInventoryDto },
  TContext
> => {
  const mutationOptions = getAdjustInventoryQuantityMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}

/**
 * @summary List audit logs with pagination and filtering
 */
export const listAuditLogs = (
  params?: ListAuditLogsParams,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<PaginatedAuditLogsResponseDto>({
    url: `/audit-logs`,
    method: 'GET',
    params,
    signal,
  })
}

export const getListAuditLogsQueryKey = (params?: ListAuditLogsParams) => {
  return [`/audit-logs`, ...(params ? [params] : [])] as const
}

export const getListAuditLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof listAuditLogs>>,
  TError = ErrorResponseDto,
>(
  params?: ListAuditLogsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAuditLogs>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListAuditLogsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listAuditLogs>>> = ({
    signal,
  }) => listAuditLogs(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listAuditLogs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAuditLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listAuditLogs>>
>
export type ListAuditLogsQueryError = ErrorResponseDto

export function useListAuditLogs<
  TData = Awaited<ReturnType<typeof listAuditLogs>>,
  TError = ErrorResponseDto,
>(
  params: undefined | ListAuditLogsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAuditLogs>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAuditLogs>>,
          TError,
          Awaited<ReturnType<typeof listAuditLogs>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAuditLogs<
  TData = Awaited<ReturnType<typeof listAuditLogs>>,
  TError = ErrorResponseDto,
>(
  params?: ListAuditLogsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAuditLogs>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAuditLogs>>,
          TError,
          Awaited<ReturnType<typeof listAuditLogs>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useListAuditLogs<
  TData = Awaited<ReturnType<typeof listAuditLogs>>,
  TError = ErrorResponseDto,
>(
  params?: ListAuditLogsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAuditLogs>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary List audit logs with pagination and filtering
 */

export function useListAuditLogs<
  TData = Awaited<ReturnType<typeof listAuditLogs>>,
  TError = ErrorResponseDto,
>(
  params?: ListAuditLogsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listAuditLogs>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getListAuditLogsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get audit log by ID
 */
export const getAuditLog = (id: string, signal?: AbortSignal) => {
  return getAxiosInstance<AuditLogResponseDto>({
    url: `/audit-logs/${id}`,
    method: 'GET',
    signal,
  })
}

export const getGetAuditLogQueryKey = (id?: string) => {
  return [`/audit-logs/${id}`] as const
}

export const getGetAuditLogQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuditLog>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuditLog>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAuditLogQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuditLog>>> = ({
    signal,
  }) => getAuditLog(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuditLog>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuditLogQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuditLog>>
>
export type GetAuditLogQueryError = ErrorResponseDto

export function useGetAuditLog<
  TData = Awaited<ReturnType<typeof getAuditLog>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuditLog>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuditLog>>,
          TError,
          Awaited<ReturnType<typeof getAuditLog>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAuditLog<
  TData = Awaited<ReturnType<typeof getAuditLog>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuditLog>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuditLog>>,
          TError,
          Awaited<ReturnType<typeof getAuditLog>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetAuditLog<
  TData = Awaited<ReturnType<typeof getAuditLog>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuditLog>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get audit log by ID
 */

export function useGetAuditLog<
  TData = Awaited<ReturnType<typeof getAuditLog>>,
  TError = ErrorResponseDto,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuditLog>>, TError, TData>
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetAuditLogQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get audit history for a specific entity
 */
export const getEntityAuditHistory = (
  entityType:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId: string,
  signal?: AbortSignal,
) => {
  return getAxiosInstance<AuditLogResponseDto[]>({
    url: `/audit-logs/entity/${entityType}/${entityId}`,
    method: 'GET',
    signal,
  })
}

export const getGetEntityAuditHistoryQueryKey = (
  entityType?:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId?: string,
) => {
  return [`/audit-logs/entity/${entityType}/${entityId}`] as const
}

export const getGetEntityAuditHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getEntityAuditHistory>>,
  TError = ErrorResponseDto,
>(
  entityType:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEntityAuditHistory>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ??
    getGetEntityAuditHistoryQueryKey(entityType, entityId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEntityAuditHistory>>
  > = ({ signal }) => getEntityAuditHistory(entityType, entityId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!(entityType && entityId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getEntityAuditHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEntityAuditHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEntityAuditHistory>>
>
export type GetEntityAuditHistoryQueryError = ErrorResponseDto

export function useGetEntityAuditHistory<
  TData = Awaited<ReturnType<typeof getEntityAuditHistory>>,
  TError = ErrorResponseDto,
>(
  entityType:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEntityAuditHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEntityAuditHistory>>,
          TError,
          Awaited<ReturnType<typeof getEntityAuditHistory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetEntityAuditHistory<
  TData = Awaited<ReturnType<typeof getEntityAuditHistory>>,
  TError = ErrorResponseDto,
>(
  entityType:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEntityAuditHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEntityAuditHistory>>,
          TError,
          Awaited<ReturnType<typeof getEntityAuditHistory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetEntityAuditHistory<
  TData = Awaited<ReturnType<typeof getEntityAuditHistory>>,
  TError = ErrorResponseDto,
>(
  entityType:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEntityAuditHistory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get audit history for a specific entity
 */

export function useGetEntityAuditHistory<
  TData = Awaited<ReturnType<typeof getEntityAuditHistory>>,
  TError = ErrorResponseDto,
>(
  entityType:
    | 'PRODUCT'
    | 'CATEGORY'
    | 'SUPPLIER'
    | 'ORDER'
    | 'ORDER_ITEM'
    | 'INVENTORY'
    | 'LOCATION'
    | 'STOCK_MOVEMENT'
    | 'PHOTO',
  entityId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEntityAuditHistory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetEntityAuditHistoryQueryOptions(
    entityType,
    entityId,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get audit history for a specific user
 */
export const getUserAuditHistory = (userId: string, signal?: AbortSignal) => {
  return getAxiosInstance<AuditLogResponseDto[]>({
    url: `/audit-logs/user/${userId}`,
    method: 'GET',
    signal,
  })
}

export const getGetUserAuditHistoryQueryKey = (userId?: string) => {
  return [`/audit-logs/user/${userId}`] as const
}

export const getGetUserAuditHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserAuditHistory>>,
  TError = ErrorResponseDto,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserAuditHistory>>,
        TError,
        TData
      >
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetUserAuditHistoryQueryKey(userId)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserAuditHistory>>
  > = ({ signal }) => getUserAuditHistory(userId, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserAuditHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserAuditHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserAuditHistory>>
>
export type GetUserAuditHistoryQueryError = ErrorResponseDto

export function useGetUserAuditHistory<
  TData = Awaited<ReturnType<typeof getUserAuditHistory>>,
  TError = ErrorResponseDto,
>(
  userId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserAuditHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserAuditHistory>>,
          TError,
          Awaited<ReturnType<typeof getUserAuditHistory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetUserAuditHistory<
  TData = Awaited<ReturnType<typeof getUserAuditHistory>>,
  TError = ErrorResponseDto,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserAuditHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserAuditHistory>>,
          TError,
          Awaited<ReturnType<typeof getUserAuditHistory>>
        >,
        'initialData'
      >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useGetUserAuditHistory<
  TData = Awaited<ReturnType<typeof getUserAuditHistory>>,
  TError = ErrorResponseDto,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserAuditHistory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
/**
 * @summary Get audit history for a specific user
 */

export function useGetUserAuditHistory<
  TData = Awaited<ReturnType<typeof getUserAuditHistory>>,
  TError = ErrorResponseDto,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserAuditHistory>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getGetUserAuditHistoryQueryOptions(userId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}
